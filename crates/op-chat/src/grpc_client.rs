//! gRPC Client for Agent Communication
//!
//! This module provides the gRPC client used by ChatActor to communicate
//! with the run-on-connection agents. It replaces D-Bus for internal
//! agent communication.
//!
//! Benefits over D-Bus:
//! - Streaming support for long-running operations
//! - Persistent connections for session lifetime
//! - Batch operations
//! - Better performance for high-frequency calls

use anyhow::Result;
use serde_json::Value;
use std::sync::Arc;
use std::collections::HashMap;
use tokio::sync::RwLock;
use tracing::{debug, error, info, warn};

// These would be generated by tonic-build from agents.proto
// For now, we define the client interface manually

/// Configuration for the gRPC agent client
#[derive(Debug, Clone)]
pub struct AgentClientConfig {
    /// Address of the agent service
    pub address: String,
    /// Connection timeout in milliseconds
    pub connect_timeout_ms: u64,
    /// Request timeout in milliseconds
    pub request_timeout_ms: u64,
    /// Maximum retry attempts
    pub max_retries: u32,
    /// Enable connection pooling
    pub pool_connections: bool,
}

impl Default for AgentClientConfig {
    fn default() -> Self {
        Self {
            address: "http://127.0.0.1:50051".to_string(),
            connect_timeout_ms: 5000,
            request_timeout_ms: 30000,
            max_retries: 3,
            pool_connections: true,
        }
    }
}

/// gRPC client for agent communication
/// 
/// This replaces the D-Bus agent executor for internal communication.
/// The chatbot uses this to call run-on-connection agents.
pub struct GrpcAgentClient {
    config: AgentClientConfig,
    /// Active sessions (session_id -> started agents)
    sessions: RwLock<HashMap<String, SessionState>>,
    /// Connection state
    connected: RwLock<bool>,
}

#[derive(Debug, Clone, Default)]
struct SessionState {
    started_agents: Vec<String>,
    started_at: Option<std::time::Instant>,
}

impl GrpcAgentClient {
    /// Create a new gRPC agent client
    pub fn new(config: AgentClientConfig) -> Self {
        Self {
            config,
            sessions: RwLock::new(HashMap::new()),
            connected: RwLock::new(false),
        }
    }
    
    /// Create with default config
    pub fn with_default_config() -> Self {
        Self::new(AgentClientConfig::default())
    }
    
    /// Connect to the agent service
    pub async fn connect(&self) -> Result<()> {
        info!(address = %self.config.address, "Connecting to agent service");
        
        // TODO: Actual tonic connection
        // let channel = tonic::transport::Channel::from_shared(self.config.address.clone())?
        //     .connect_timeout(Duration::from_millis(self.config.connect_timeout_ms))
        //     .connect()
        //     .await?;
        
        *self.connected.write().await = true;
        info!("Connected to agent service");
        Ok(())
    }
    
    /// Start a session (starts run-on-connection agents)
    pub async fn start_session(
        &self,
        session_id: &str,
        client_name: &str,
    ) -> Result<Vec<String>> {
        info!(session = %session_id, client = %client_name, "Starting agent session");
        
        // Run-on-connection agents to start
        let agents_to_start = vec![
            "rust_pro",
            "backend_architect", 
            "sequential_thinking",
            "memory",
            "context_manager",
        ];
        
        // TODO: Actual gRPC call
        // let request = tonic::Request::new(StartSessionRequest {
        //     session_id: session_id.to_string(),
        //     client_name: client_name.to_string(),
        //     metadata: HashMap::new(),
        // });
        // let response = self.client.start_session(request).await?;
        
        let state = SessionState {
            started_agents: agents_to_start.iter().map(|s| s.to_string()).collect(),
            started_at: Some(std::time::Instant::now()),
        };
        
        let started = state.started_agents.clone();
        self.sessions.write().await.insert(session_id.to_string(), state);
        
        info!(session = %session_id, agents = ?started, "Session started with agents");
        Ok(started)
    }
    
    /// End a session
    pub async fn end_session(&self, session_id: &str) -> Result<()> {
        info!(session = %session_id, "Ending agent session");
        
        // TODO: Actual gRPC call
        // let request = tonic::Request::new(EndSessionRequest {
        //     session_id: session_id.to_string(),
        // });
        // self.client.end_session(request).await?;
        
        self.sessions.write().await.remove(session_id);
        Ok(())
    }
    
    /// Execute an operation on an agent
    pub async fn execute(
        &self,
        session_id: &str,
        agent_id: &str,
        operation: &str,
        arguments: Value,
    ) -> Result<Value> {
        debug!(
            session = %session_id,
            agent = %agent_id,
            operation = %operation,
            "Executing agent operation"
        );
        
        // TODO: Actual gRPC call
        // let request = tonic::Request::new(ExecuteRequest {
        //     session_id: session_id.to_string(),
        //     agent_id: agent_id.to_string(),
        //     operation: operation.to_string(),
        //     arguments_json: serde_json::to_string(&arguments)?,
        //     timeout_ms: self.config.request_timeout_ms as i64,
        // });
        // let response = self.client.execute(request).await?;
        
        // Simulate successful execution
        Ok(serde_json::json!({
            "agent": agent_id,
            "operation": operation,
            "success": true,
            "simulated": true
        }))
    }
    
    /// Execute with streaming response
    pub async fn execute_stream(
        &self,
        session_id: &str,
        agent_id: &str,
        operation: &str,
        arguments: Value,
        mut on_chunk: impl FnMut(StreamChunk) + Send,
    ) -> Result<Value> {
        debug!(
            session = %session_id,
            agent = %agent_id,
            operation = %operation,
            "Executing streaming agent operation"
        );
        
        // TODO: Actual gRPC streaming call
        // let request = tonic::Request::new(ExecuteRequest { ... });
        // let mut stream = self.client.execute_stream(request).await?.into_inner();
        // while let Some(chunk) = stream.next().await {
        //     on_chunk(chunk.into());
        // }
        
        // Simulate streaming
        on_chunk(StreamChunk {
            content: format!("Starting {} operation...\n", operation),
            stream_type: StreamType::Stdout,
            is_final: false,
        });
        
        on_chunk(StreamChunk {
            content: "Operation complete.\n".to_string(),
            stream_type: StreamType::Stdout,
            is_final: true,
        });
        
        Ok(serde_json::json!({
            "agent": agent_id,
            "operation": operation,
            "success": true
        }))
    }
    
    /// Batch execute multiple operations
    pub async fn batch_execute(
        &self,
        session_id: &str,
        operations: Vec<(String, String, Value)>, // (agent_id, operation, args)
        parallel: bool,
    ) -> Result<Vec<Result<Value>>> {
        info!(
            session = %session_id,
            count = operations.len(),
            parallel = %parallel,
            "Batch executing agent operations"
        );
        
        if parallel {
            // Execute in parallel
            let futures: Vec<_> = operations
                .into_iter()
                .map(|(agent, op, args)| {
                    let session = session_id.to_string();
                    async move {
                        self.execute(&session, &agent, &op, args).await
                    }
                })
                .collect();
            
            let results = futures::future::join_all(futures).await;
            Ok(results)
        } else {
            // Execute sequentially
            let mut results = Vec::new();
            for (agent, op, args) in operations {
                results.push(self.execute(session_id, &agent, &op, args).await);
            }
            Ok(results)
        }
    }
    
    // === Convenience methods for specific agents ===
    
    /// Memory: Remember a value
    pub async fn memory_remember(
        &self,
        session_id: &str,
        key: &str,
        value: &str,
    ) -> Result<()> {
        self.execute(
            session_id,
            "memory",
            "remember",
            serde_json::json!({ "key": key, "value": value }),
        ).await?;
        Ok(())
    }
    
    /// Memory: Recall a value
    pub async fn memory_recall(
        &self,
        session_id: &str,
        key: &str,
    ) -> Result<Option<String>> {
        let result = self.execute(
            session_id,
            "memory",
            "recall",
            serde_json::json!({ "key": key }),
        ).await?;
        
        Ok(result.get("value").and_then(|v| v.as_str()).map(String::from))
    }
    
    /// Sequential Thinking: Start a chain
    pub async fn think_start(
        &self,
        session_id: &str,
        problem: &str,
        max_steps: i32,
    ) -> Result<String> {
        let result = self.execute(
            session_id,
            "sequential_thinking",
            "start_chain",
            serde_json::json!({
                "problem": problem,
                "max_steps": max_steps
            }),
        ).await?;
        
        Ok(result.get("chain_id").and_then(|v| v.as_str()).unwrap_or("").to_string())
    }
    
    /// Sequential Thinking: Add a thought
    pub async fn think(
        &self,
        session_id: &str,
        chain_id: &str,
        thought: &str,
        step: i32,
    ) -> Result<Value> {
        self.execute(
            session_id,
            "sequential_thinking",
            "think",
            serde_json::json!({
                "chain_id": chain_id,
                "thought": thought,
                "step": step
            }),
        ).await
    }
    
    /// Rust Pro: Check/build with streaming
    pub async fn cargo_check(
        &self,
        session_id: &str,
        path: &str,
        on_output: impl FnMut(StreamChunk) + Send,
    ) -> Result<Value> {
        self.execute_stream(
            session_id,
            "rust_pro",
            "check",
            serde_json::json!({ "path": path }),
            on_output,
        ).await
    }
    
    /// Rust Pro: Build with streaming
    pub async fn cargo_build(
        &self,
        session_id: &str,
        path: &str,
        release: bool,
        on_output: impl FnMut(StreamChunk) + Send,
    ) -> Result<Value> {
        self.execute_stream(
            session_id,
            "rust_pro",
            "build",
            serde_json::json!({ "path": path, "release": release }),
            on_output,
        ).await
    }
    
    /// Context Manager: Save context
    pub async fn context_save(
        &self,
        session_id: &str,
        name: &str,
        content: &str,
        tags: Vec<String>,
    ) -> Result<()> {
        self.execute(
            session_id,
            "context_manager",
            "save",
            serde_json::json!({
                "name": name,
                "content": content,
                "tags": tags
            }),
        ).await?;
        Ok(())
    }
    
    /// Context Manager: Load context
    pub async fn context_load(
        &self,
        session_id: &str,
        name: &str,
    ) -> Result<Option<String>> {
        let result = self.execute(
            session_id,
            "context_manager",
            "load",
            serde_json::json!({ "name": name }),
        ).await?;
        
        if result.get("found").and_then(|v| v.as_bool()).unwrap_or(false) {
            Ok(result.get("content").and_then(|v| v.as_str()).map(String::from))
        } else {
            Ok(None)
        }
    }
    
    /// Check if connected
    pub async fn is_connected(&self) -> bool {
        *self.connected.read().await
    }
    
    /// Get active session count
    pub async fn session_count(&self) -> usize {
        self.sessions.read().await.len()
    }
}

/// A chunk from a streaming response
#[derive(Debug, Clone)]
pub struct StreamChunk {
    pub content: String,
    pub stream_type: StreamType,
    pub is_final: bool,
}

/// Type of stream content
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum StreamType {
    Stdout,
    Stderr,
    Progress,
    Result,
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_session_lifecycle() {
        let client = GrpcAgentClient::with_default_config();
        assert_eq!(client.session_count().await, 0);
        
        // Start session
        let agents = client.start_session("test-1", "test-client").await.unwrap();
        assert!(!agents.is_empty());
        assert!(agents.contains(&"rust_pro".to_string()));
        assert!(agents.contains(&"memory".to_string()));
        assert_eq!(client.session_count().await, 1);
        
        // End session
        client.end_session("test-1").await.unwrap();
        assert_eq!(client.session_count().await, 0);
    }
    
    #[tokio::test]
    async fn test_execute() {
        let client = GrpcAgentClient::with_default_config();
        client.start_session("test-2", "test-client").await.unwrap();
        
        let result = client.execute(
            "test-2",
            "memory",
            "remember",
            serde_json::json!({ "key": "foo", "value": "bar" }),
        ).await.unwrap();
        
        assert!(result.get("success").and_then(|v| v.as_bool()).unwrap_or(false));
    }
    
    #[tokio::test]
    async fn test_batch_execute() {
        let client = GrpcAgentClient::with_default_config();
        client.start_session("test-3", "test-client").await.unwrap();
        
        let operations = vec![
            ("memory".into(), "remember".into(), serde_json::json!({ "key": "a", "value": "1" })),
            ("memory".into(), "remember".into(), serde_json::json!({ "key": "b", "value": "2" })),
            ("memory".into(), "list".into(), serde_json::json!({})),
        ];
        
        let results = client.batch_execute("test-3", operations, true).await.unwrap();
        assert_eq!(results.len(), 3);
    }
}
