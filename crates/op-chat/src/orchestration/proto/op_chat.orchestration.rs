// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartSessionRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub client_name: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Empty = use defaults
    #[prost(string, repeated, tag = "4")]
    pub requested_agents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "5")]
    pub timeout_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartSessionResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub started_agents: ::prost::alloc::vec::Vec<AgentInfo>,
    #[prost(message, repeated, tag = "4")]
    pub failed_agents: ::prost::alloc::vec::Vec<AgentError>,
    #[prost(int64, tag = "5")]
    pub started_at_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndSessionRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub force: bool,
    #[prost(int64, tag = "3")]
    pub timeout_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndSessionResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, repeated, tag = "2")]
    pub stopped_agents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "3")]
    pub session_duration_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheckRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub include_metrics: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheckResponse {
    #[prost(bool, tag = "1")]
    pub healthy: bool,
    #[prost(string, tag = "2")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(enumeration = "AgentStatus", tag = "3")]
    pub status: i32,
    #[prost(int64, tag = "4")]
    pub uptime_ms: i64,
    #[prost(map = "string, string", tag = "5")]
    pub metrics: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "6")]
    pub last_error: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatchAgentsRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// Empty = all agents
    #[prost(string, repeated, tag = "2")]
    pub agent_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "3")]
    pub include_heartbeats: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentStatusEvent {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(enumeration = "AgentStatus", tag = "2")]
    pub status: i32,
    #[prost(int64, tag = "3")]
    pub timestamp_ms: i64,
    #[prost(string, tag = "4")]
    pub message: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "5")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShutdownRequest {
    #[prost(bool, tag = "1")]
    pub force: bool,
    #[prost(int64, tag = "2")]
    pub timeout_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShutdownResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(int32, tag = "2")]
    pub agents_stopped: i32,
    #[prost(string, repeated, tag = "3")]
    pub errors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentInfo {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub agent_type: ::prost::alloc::string::String,
    #[prost(enumeration = "AgentStatus", tag = "3")]
    pub status: i32,
    #[prost(int32, tag = "4")]
    pub priority: i32,
    #[prost(string, repeated, tag = "5")]
    pub operations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "6")]
    pub started_at_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentError {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub error_code: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub retryable: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub operation: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub arguments_json: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub timeout_ms: i64,
    #[prost(string, tag = "6")]
    pub correlation_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub options: ::core::option::Option<ExecutionOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionOptions {
    #[prost(bool, tag = "1")]
    pub stream_output: bool,
    #[prost(int32, tag = "2")]
    pub max_retries: i32,
    #[prost(int64, tag = "3")]
    pub retry_delay_ms: i64,
    #[prost(bool, tag = "4")]
    pub allow_partial_results: bool,
    #[prost(map = "string, string", tag = "5")]
    pub context: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteResponse {
    #[prost(string, tag = "1")]
    pub correlation_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub operation: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub success: bool,
    #[prost(string, tag = "5")]
    pub result_json: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub error: ::core::option::Option<ExecuteError>,
    #[prost(int64, tag = "7")]
    pub execution_time_ms: i64,
    #[prost(map = "string, string", tag = "8")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteError {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub details: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub retryable: bool,
    #[prost(string, tag = "5")]
    pub stack_trace: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteChunk {
    #[prost(string, tag = "1")]
    pub correlation_id: ::prost::alloc::string::String,
    #[prost(enumeration = "ChunkType", tag = "2")]
    pub chunk_type: i32,
    #[prost(string, tag = "3")]
    pub content: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub is_final: bool,
    #[prost(int32, tag = "5")]
    pub sequence: i32,
    #[prost(int64, tag = "6")]
    pub timestamp_ms: i64,
    /// Only set if is_final and error occurred
    #[prost(message, optional, tag = "7")]
    pub error: ::core::option::Option<ExecuteError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchExecuteRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<ExecuteRequest>,
    #[prost(bool, tag = "3")]
    pub parallel: bool,
    #[prost(bool, tag = "4")]
    pub stop_on_error: bool,
    #[prost(int64, tag = "5")]
    pub timeout_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub correlation_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub correlation_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub was_running: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RememberRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub value: ::prost::alloc::string::String,
    /// 0 = no expiry
    #[prost(int64, tag = "4")]
    pub ttl_secs: i64,
    #[prost(string, repeated, tag = "5")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If false, fail if key exists
    #[prost(bool, tag = "6")]
    pub overwrite: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RememberResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub was_overwrite: bool,
    /// 0 if no expiry
    #[prost(int64, tag = "4")]
    pub expires_at_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecallRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub include_metadata: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecallResponse {
    #[prost(bool, tag = "1")]
    pub found: bool,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub value: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "5")]
    pub created_at_ms: i64,
    #[prost(int64, tag = "6")]
    pub accessed_at_ms: i64,
    #[prost(int32, tag = "7")]
    pub access_count: i32,
    #[prost(int64, tag = "8")]
    pub expires_at_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForgetRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForgetResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(bool, tag = "2")]
    pub existed: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListKeysRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// Glob pattern, empty = all
    #[prost(string, tag = "2")]
    pub pattern: ::prost::alloc::string::String,
    /// 0 = no limit
    #[prost(int32, tag = "3")]
    pub limit: i32,
    #[prost(int32, tag = "4")]
    pub offset: i32,
    #[prost(string, tag = "5")]
    pub tag_filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListKeysResponse {
    #[prost(string, repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "2")]
    pub total_count: i32,
    #[prost(bool, tag = "3")]
    pub has_more: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchMemoryRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub limit: i32,
    #[prost(float, tag = "4")]
    pub min_score: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchMemoryResponse {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<MemorySearchResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemorySearchResult {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
    #[prost(float, tag = "3")]
    pub score: f32,
    #[prost(string, repeated, tag = "4")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkRecallRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkForgetRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkOperationResponse {
    #[prost(int32, tag = "1")]
    pub success_count: i32,
    #[prost(int32, tag = "2")]
    pub failure_count: i32,
    #[prost(message, repeated, tag = "3")]
    pub errors: ::prost::alloc::vec::Vec<BulkOperationError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkOperationError {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub error_code: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub error_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartChainRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub problem: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub max_steps: i32,
    #[prost(string, tag = "4")]
    pub context: ::prost::alloc::string::String,
    #[prost(enumeration = "ThinkingStyle", tag = "5")]
    pub style: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartChainResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub max_steps: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddThoughtRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub thought: ::prost::alloc::string::String,
    #[prost(enumeration = "ThoughtType", tag = "4")]
    pub thought_type: i32,
    /// 0.0 to 1.0
    #[prost(float, tag = "5")]
    pub confidence: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddThoughtResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub step: i32,
    #[prost(int32, tag = "4")]
    pub remaining_steps: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThoughtEvent {
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub step: i32,
    #[prost(int32, tag = "3")]
    pub total_steps: i32,
    #[prost(string, tag = "4")]
    pub thought: ::prost::alloc::string::String,
    #[prost(enumeration = "ThoughtType", tag = "5")]
    pub thought_type: i32,
    #[prost(float, tag = "6")]
    pub confidence: f32,
    #[prost(enumeration = "ChainStatus", tag = "7")]
    pub status: i32,
    #[prost(int64, tag = "8")]
    pub timestamp_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConcludeRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub chain_id: ::prost::alloc::string::String,
    /// Conclude even if not all steps used
    #[prost(bool, tag = "3")]
    pub force: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConcludeResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub conclusion: ::prost::alloc::string::String,
    #[prost(float, tag = "4")]
    pub overall_confidence: f32,
    #[prost(int32, tag = "5")]
    pub steps_used: i32,
    #[prost(string, repeated, tag = "6")]
    pub key_insights: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetChainRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub chain_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetChainResponse {
    #[prost(bool, tag = "1")]
    pub found: bool,
    #[prost(string, tag = "2")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub problem: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub thoughts: ::prost::alloc::vec::Vec<ThoughtEvent>,
    #[prost(enumeration = "ChainStatus", tag = "5")]
    pub status: i32,
    #[prost(string, tag = "6")]
    pub conclusion: ::prost::alloc::string::String,
    #[prost(int64, tag = "7")]
    pub started_at_ms: i64,
    #[prost(int64, tag = "8")]
    pub completed_at_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForkChainRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub chain_id: ::prost::alloc::string::String,
    /// Which step to fork from
    #[prost(int32, tag = "3")]
    pub fork_at_step: i32,
    #[prost(string, tag = "4")]
    pub alternative_thought: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForkChainResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub new_chain_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub parent_chain_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub forked_at_step: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveContextRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub content: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "5")]
    pub overwrite: bool,
    #[prost(enumeration = "ContextType", tag = "6")]
    pub context_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveContextResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub size_bytes: i64,
    #[prost(string, tag = "4")]
    pub version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadContextRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Empty = latest
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadContextResponse {
    #[prost(bool, tag = "1")]
    pub found: bool,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub content: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "ContextType", tag = "5")]
    pub context_type: i32,
    #[prost(int64, tag = "6")]
    pub created_at_ms: i64,
    #[prost(int64, tag = "7")]
    pub updated_at_ms: i64,
    #[prost(string, tag = "8")]
    pub version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContextsRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tag_filter: ::prost::alloc::string::String,
    #[prost(enumeration = "ContextType", tag = "3")]
    pub type_filter: i32,
    #[prost(int32, tag = "4")]
    pub limit: i32,
    #[prost(int32, tag = "5")]
    pub offset: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContextsResponse {
    #[prost(message, repeated, tag = "1")]
    pub contexts: ::prost::alloc::vec::Vec<ContextInfo>,
    #[prost(int32, tag = "2")]
    pub total_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContextInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub size_bytes: i64,
    #[prost(string, repeated, tag = "3")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "ContextType", tag = "4")]
    pub context_type: i32,
    #[prost(int64, tag = "5")]
    pub updated_at_ms: i64,
    #[prost(string, tag = "6")]
    pub version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteContextRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub all_versions: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteContextResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(int32, tag = "2")]
    pub versions_deleted: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportContextRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// Empty = all
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// json, yaml, tar
    #[prost(string, tag = "3")]
    pub format: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub include_history: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportChunk {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "2")]
    pub offset: i64,
    #[prost(int64, tag = "3")]
    pub total_size: i64,
    #[prost(bool, tag = "4")]
    pub is_final: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportChunk {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "2")]
    pub is_final: bool,
    #[prost(string, tag = "3")]
    pub format: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub overwrite_existing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportContextResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(int32, tag = "2")]
    pub imported_count: i32,
    #[prost(int32, tag = "3")]
    pub skipped_count: i32,
    #[prost(string, repeated, tag = "4")]
    pub errors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeContextsRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub source_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub target_name: ::prost::alloc::string::String,
    #[prost(enumeration = "MergeStrategy", tag = "4")]
    pub strategy: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeContextsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub target_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub merged_size_bytes: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CargoRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// Project path, default "."
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub release: bool,
    #[prost(string, repeated, tag = "4")]
    pub features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Specific package in workspace
    #[prost(string, tag = "5")]
    pub package: ::prost::alloc::string::String,
    /// Test filter
    #[prost(string, tag = "6")]
    pub filter: ::prost::alloc::string::String,
    /// For clippy/fmt --fix
    #[prost(bool, tag = "7")]
    pub fix: bool,
    #[prost(bool, tag = "8")]
    pub all_targets: bool,
    #[prost(int64, tag = "9")]
    pub timeout_secs: i64,
    #[prost(map = "string, string", tag = "10")]
    pub env: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CargoResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub stdout: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub stderr: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub exit_code: i32,
    #[prost(int64, tag = "5")]
    pub duration_ms: i64,
    #[prost(message, optional, tag = "6")]
    pub metadata: ::core::option::Option<CargoMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CargoMetadata {
    #[prost(int32, tag = "1")]
    pub warnings: i32,
    #[prost(int32, tag = "2")]
    pub errors: i32,
    #[prost(string, repeated, tag = "3")]
    pub failed_targets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CargoOutputLine {
    #[prost(string, tag = "1")]
    pub line: ::prost::alloc::string::String,
    #[prost(enumeration = "OutputStreamType", tag = "2")]
    pub stream: i32,
    #[prost(int64, tag = "3")]
    pub timestamp_ms: i64,
    #[prost(bool, tag = "4")]
    pub is_final: bool,
    /// Only set when is_final
    #[prost(int32, tag = "5")]
    pub exit_code: i32,
    /// Only set when is_final
    #[prost(int64, tag = "6")]
    pub duration_ms: i64,
    /// Only set when is_final
    #[prost(message, optional, tag = "7")]
    pub metadata: ::core::option::Option<CargoMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionResponse {
    #[prost(string, tag = "1")]
    pub rustc_version: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub cargo_version: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub clippy_version: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub rustfmt_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzeRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(enumeration = "AnalysisType", tag = "3")]
    pub analysis_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzeResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub result_json: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArchitectAnalyzeRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    /// file, module, crate, workspace
    #[prost(string, tag = "3")]
    pub scope: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub focus_areas: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArchitectAnalyzeResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub analysis_json: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub findings: ::prost::alloc::vec::Vec<ArchitectureFinding>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArchitectureFinding {
    /// structure, dependency, pattern, concern
    #[prost(string, tag = "1")]
    pub category: ::prost::alloc::string::String,
    /// info, warning, critical
    #[prost(string, tag = "2")]
    pub severity: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub location: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub suggestion: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArchitectDesignRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub context: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub requirements: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub constraints: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "DesignStyle", tag = "5")]
    pub style: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArchitectDesignResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub design_json: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub components: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub interfaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub trade_offs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArchitectReviewRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub design: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub review_criteria: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArchitectReviewResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub review_json: ::prost::alloc::string::String,
    /// 0-100
    #[prost(int32, tag = "3")]
    pub score: i32,
    #[prost(message, repeated, tag = "4")]
    pub issues: ::prost::alloc::vec::Vec<ReviewIssue>,
    #[prost(string, repeated, tag = "5")]
    pub strengths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReviewIssue {
    #[prost(string, tag = "1")]
    pub category: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub severity: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub recommendation: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArchitectSuggestRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub context: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub constraints: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "4")]
    pub max_suggestions: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArchitectSuggestResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(message, repeated, tag = "2")]
    pub suggestions: ::prost::alloc::vec::Vec<Suggestion>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Suggestion {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rationale: ::prost::alloc::string::String,
    /// 1-5 (low to high)
    #[prost(int32, tag = "4")]
    pub effort: i32,
    /// 1-5 (low to high)
    #[prost(int32, tag = "5")]
    pub impact: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArchitectDocumentRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(enumeration = "DocumentFormat", tag = "3")]
    pub format: i32,
    #[prost(string, repeated, tag = "4")]
    pub sections: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentChunk {
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub section: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub is_final: bool,
    #[prost(int32, tag = "4")]
    pub sequence: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkstackExecuteRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub workstack_id: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub variables: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(bool, tag = "4")]
    pub dry_run: bool,
    #[prost(int64, tag = "5")]
    pub timeout_secs: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkstackEvent {
    #[prost(string, tag = "1")]
    pub workstack_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub execution_id: ::prost::alloc::string::String,
    #[prost(enumeration = "WorkstackEventType", tag = "3")]
    pub event_type: i32,
    #[prost(string, tag = "4")]
    pub phase_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub details_json: ::prost::alloc::string::String,
    #[prost(int64, tag = "7")]
    pub timestamp_ms: i64,
    #[prost(message, optional, tag = "8")]
    pub progress: ::core::option::Option<WorkstackProgress>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkstackProgress {
    #[prost(int32, tag = "1")]
    pub current_phase: i32,
    #[prost(int32, tag = "2")]
    pub total_phases: i32,
    #[prost(string, tag = "3")]
    pub current_phase_id: ::prost::alloc::string::String,
    #[prost(float, tag = "4")]
    pub percent_complete: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkstackStatusRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkstackStatusResponse {
    #[prost(bool, tag = "1")]
    pub found: bool,
    #[prost(string, tag = "2")]
    pub execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub workstack_id: ::prost::alloc::string::String,
    #[prost(enumeration = "WorkstackExecutionStatus", tag = "4")]
    pub status: i32,
    #[prost(message, optional, tag = "5")]
    pub progress: ::core::option::Option<WorkstackProgress>,
    #[prost(message, repeated, tag = "6")]
    pub phases: ::prost::alloc::vec::Vec<PhaseStatus>,
    #[prost(int64, tag = "7")]
    pub started_at_ms: i64,
    #[prost(int64, tag = "8")]
    pub completed_at_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PhaseStatus {
    #[prost(string, tag = "1")]
    pub phase_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub phase_name: ::prost::alloc::string::String,
    #[prost(enumeration = "WorkstackExecutionStatus", tag = "3")]
    pub status: i32,
    #[prost(string, tag = "4")]
    pub result_json: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub error: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub started_at_ms: i64,
    #[prost(int64, tag = "7")]
    pub completed_at_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkstackCancelRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub execution_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub rollback: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkstackCancelResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(bool, tag = "2")]
    pub will_rollback: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkstackRollbackRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub execution_id: ::prost::alloc::string::String,
    /// Empty = full rollback
    #[prost(string, tag = "3")]
    pub rollback_to_phase: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkstackRollbackResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, repeated, tag = "2")]
    pub rolled_back_phases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub errors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkstacksRequest {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub category: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkstacksResponse {
    #[prost(message, repeated, tag = "1")]
    pub workstacks: ::prost::alloc::vec::Vec<WorkstackInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkstackInfo {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub category: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub required_agents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "6")]
    pub phase_count: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AgentStatus {
    Unknown = 0,
    Starting = 1,
    Running = 2,
    Busy = 3,
    Stopping = 4,
    Stopped = 5,
    Error = 6,
    Unresponsive = 7,
}
impl AgentStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AgentStatus::Unknown => "AGENT_STATUS_UNKNOWN",
            AgentStatus::Starting => "AGENT_STATUS_STARTING",
            AgentStatus::Running => "AGENT_STATUS_RUNNING",
            AgentStatus::Busy => "AGENT_STATUS_BUSY",
            AgentStatus::Stopping => "AGENT_STATUS_STOPPING",
            AgentStatus::Stopped => "AGENT_STATUS_STOPPED",
            AgentStatus::Error => "AGENT_STATUS_ERROR",
            AgentStatus::Unresponsive => "AGENT_STATUS_UNRESPONSIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AGENT_STATUS_UNKNOWN" => Some(Self::Unknown),
            "AGENT_STATUS_STARTING" => Some(Self::Starting),
            "AGENT_STATUS_RUNNING" => Some(Self::Running),
            "AGENT_STATUS_BUSY" => Some(Self::Busy),
            "AGENT_STATUS_STOPPING" => Some(Self::Stopping),
            "AGENT_STATUS_STOPPED" => Some(Self::Stopped),
            "AGENT_STATUS_ERROR" => Some(Self::Error),
            "AGENT_STATUS_UNRESPONSIVE" => Some(Self::Unresponsive),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChunkType {
    Unknown = 0,
    Stdout = 1,
    Stderr = 2,
    Progress = 3,
    Result = 4,
    Heartbeat = 5,
}
impl ChunkType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ChunkType::Unknown => "CHUNK_TYPE_UNKNOWN",
            ChunkType::Stdout => "CHUNK_TYPE_STDOUT",
            ChunkType::Stderr => "CHUNK_TYPE_STDERR",
            ChunkType::Progress => "CHUNK_TYPE_PROGRESS",
            ChunkType::Result => "CHUNK_TYPE_RESULT",
            ChunkType::Heartbeat => "CHUNK_TYPE_HEARTBEAT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHUNK_TYPE_UNKNOWN" => Some(Self::Unknown),
            "CHUNK_TYPE_STDOUT" => Some(Self::Stdout),
            "CHUNK_TYPE_STDERR" => Some(Self::Stderr),
            "CHUNK_TYPE_PROGRESS" => Some(Self::Progress),
            "CHUNK_TYPE_RESULT" => Some(Self::Result),
            "CHUNK_TYPE_HEARTBEAT" => Some(Self::Heartbeat),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ThinkingStyle {
    Default = 0,
    Analytical = 1,
    Creative = 2,
    Critical = 3,
    Systematic = 4,
}
impl ThinkingStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ThinkingStyle::Default => "THINKING_STYLE_DEFAULT",
            ThinkingStyle::Analytical => "THINKING_STYLE_ANALYTICAL",
            ThinkingStyle::Creative => "THINKING_STYLE_CREATIVE",
            ThinkingStyle::Critical => "THINKING_STYLE_CRITICAL",
            ThinkingStyle::Systematic => "THINKING_STYLE_SYSTEMATIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "THINKING_STYLE_DEFAULT" => Some(Self::Default),
            "THINKING_STYLE_ANALYTICAL" => Some(Self::Analytical),
            "THINKING_STYLE_CREATIVE" => Some(Self::Creative),
            "THINKING_STYLE_CRITICAL" => Some(Self::Critical),
            "THINKING_STYLE_SYSTEMATIC" => Some(Self::Systematic),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ThoughtType {
    Observation = 0,
    Hypothesis = 1,
    Analysis = 2,
    Conclusion = 3,
    Question = 4,
    Reflection = 5,
}
impl ThoughtType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ThoughtType::Observation => "THOUGHT_TYPE_OBSERVATION",
            ThoughtType::Hypothesis => "THOUGHT_TYPE_HYPOTHESIS",
            ThoughtType::Analysis => "THOUGHT_TYPE_ANALYSIS",
            ThoughtType::Conclusion => "THOUGHT_TYPE_CONCLUSION",
            ThoughtType::Question => "THOUGHT_TYPE_QUESTION",
            ThoughtType::Reflection => "THOUGHT_TYPE_REFLECTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "THOUGHT_TYPE_OBSERVATION" => Some(Self::Observation),
            "THOUGHT_TYPE_HYPOTHESIS" => Some(Self::Hypothesis),
            "THOUGHT_TYPE_ANALYSIS" => Some(Self::Analysis),
            "THOUGHT_TYPE_CONCLUSION" => Some(Self::Conclusion),
            "THOUGHT_TYPE_QUESTION" => Some(Self::Question),
            "THOUGHT_TYPE_REFLECTION" => Some(Self::Reflection),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChainStatus {
    Unknown = 0,
    Thinking = 1,
    Analyzing = 2,
    Concluding = 3,
    Complete = 4,
    Stuck = 5,
    Error = 6,
}
impl ChainStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ChainStatus::Unknown => "CHAIN_STATUS_UNKNOWN",
            ChainStatus::Thinking => "CHAIN_STATUS_THINKING",
            ChainStatus::Analyzing => "CHAIN_STATUS_ANALYZING",
            ChainStatus::Concluding => "CHAIN_STATUS_CONCLUDING",
            ChainStatus::Complete => "CHAIN_STATUS_COMPLETE",
            ChainStatus::Stuck => "CHAIN_STATUS_STUCK",
            ChainStatus::Error => "CHAIN_STATUS_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHAIN_STATUS_UNKNOWN" => Some(Self::Unknown),
            "CHAIN_STATUS_THINKING" => Some(Self::Thinking),
            "CHAIN_STATUS_ANALYZING" => Some(Self::Analyzing),
            "CHAIN_STATUS_CONCLUDING" => Some(Self::Concluding),
            "CHAIN_STATUS_COMPLETE" => Some(Self::Complete),
            "CHAIN_STATUS_STUCK" => Some(Self::Stuck),
            "CHAIN_STATUS_ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ContextType {
    Generic = 0,
    Project = 1,
    Conversation = 2,
    Task = 3,
    Knowledge = 4,
}
impl ContextType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ContextType::Generic => "CONTEXT_TYPE_GENERIC",
            ContextType::Project => "CONTEXT_TYPE_PROJECT",
            ContextType::Conversation => "CONTEXT_TYPE_CONVERSATION",
            ContextType::Task => "CONTEXT_TYPE_TASK",
            ContextType::Knowledge => "CONTEXT_TYPE_KNOWLEDGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONTEXT_TYPE_GENERIC" => Some(Self::Generic),
            "CONTEXT_TYPE_PROJECT" => Some(Self::Project),
            "CONTEXT_TYPE_CONVERSATION" => Some(Self::Conversation),
            "CONTEXT_TYPE_TASK" => Some(Self::Task),
            "CONTEXT_TYPE_KNOWLEDGE" => Some(Self::Knowledge),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MergeStrategy {
    Concat = 0,
    Dedupe = 1,
    Latest = 2,
}
impl MergeStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MergeStrategy::Concat => "MERGE_STRATEGY_CONCAT",
            MergeStrategy::Dedupe => "MERGE_STRATEGY_DEDUPE",
            MergeStrategy::Latest => "MERGE_STRATEGY_LATEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MERGE_STRATEGY_CONCAT" => Some(Self::Concat),
            "MERGE_STRATEGY_DEDUPE" => Some(Self::Dedupe),
            "MERGE_STRATEGY_LATEST" => Some(Self::Latest),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OutputStreamType {
    OutputStreamStdout = 0,
    OutputStreamStderr = 1,
    /// Parsed compiler messages
    OutputStreamCompiler = 2,
}
impl OutputStreamType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OutputStreamType::OutputStreamStdout => "OUTPUT_STREAM_STDOUT",
            OutputStreamType::OutputStreamStderr => "OUTPUT_STREAM_STDERR",
            OutputStreamType::OutputStreamCompiler => "OUTPUT_STREAM_COMPILER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OUTPUT_STREAM_STDOUT" => Some(Self::OutputStreamStdout),
            "OUTPUT_STREAM_STDERR" => Some(Self::OutputStreamStderr),
            "OUTPUT_STREAM_COMPILER" => Some(Self::OutputStreamCompiler),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AnalysisType {
    Dependencies = 0,
    Structure = 1,
    Complexity = 2,
    Unused = 3,
}
impl AnalysisType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AnalysisType::Dependencies => "ANALYSIS_TYPE_DEPENDENCIES",
            AnalysisType::Structure => "ANALYSIS_TYPE_STRUCTURE",
            AnalysisType::Complexity => "ANALYSIS_TYPE_COMPLEXITY",
            AnalysisType::Unused => "ANALYSIS_TYPE_UNUSED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ANALYSIS_TYPE_DEPENDENCIES" => Some(Self::Dependencies),
            "ANALYSIS_TYPE_STRUCTURE" => Some(Self::Structure),
            "ANALYSIS_TYPE_COMPLEXITY" => Some(Self::Complexity),
            "ANALYSIS_TYPE_UNUSED" => Some(Self::Unused),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DesignStyle {
    Minimal = 0,
    Comprehensive = 1,
    Iterative = 2,
}
impl DesignStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DesignStyle::Minimal => "DESIGN_STYLE_MINIMAL",
            DesignStyle::Comprehensive => "DESIGN_STYLE_COMPREHENSIVE",
            DesignStyle::Iterative => "DESIGN_STYLE_ITERATIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DESIGN_STYLE_MINIMAL" => Some(Self::Minimal),
            "DESIGN_STYLE_COMPREHENSIVE" => Some(Self::Comprehensive),
            "DESIGN_STYLE_ITERATIVE" => Some(Self::Iterative),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DocumentFormat {
    Markdown = 0,
    Html = 1,
    Asciidoc = 2,
}
impl DocumentFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DocumentFormat::Markdown => "DOCUMENT_FORMAT_MARKDOWN",
            DocumentFormat::Html => "DOCUMENT_FORMAT_HTML",
            DocumentFormat::Asciidoc => "DOCUMENT_FORMAT_ASCIIDOC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DOCUMENT_FORMAT_MARKDOWN" => Some(Self::Markdown),
            "DOCUMENT_FORMAT_HTML" => Some(Self::Html),
            "DOCUMENT_FORMAT_ASCIIDOC" => Some(Self::Asciidoc),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkstackEventType {
    WorkstackEventStarted = 0,
    WorkstackEventPhaseStarted = 1,
    WorkstackEventPhaseProgress = 2,
    WorkstackEventPhaseCompleted = 3,
    WorkstackEventPhaseFailed = 4,
    WorkstackEventPhaseSkipped = 5,
    WorkstackEventCompleted = 6,
    WorkstackEventFailed = 7,
    WorkstackEventRollbackStarted = 8,
    WorkstackEventRollbackCompleted = 9,
}
impl WorkstackEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            WorkstackEventType::WorkstackEventStarted => "WORKSTACK_EVENT_STARTED",
            WorkstackEventType::WorkstackEventPhaseStarted => {
                "WORKSTACK_EVENT_PHASE_STARTED"
            }
            WorkstackEventType::WorkstackEventPhaseProgress => {
                "WORKSTACK_EVENT_PHASE_PROGRESS"
            }
            WorkstackEventType::WorkstackEventPhaseCompleted => {
                "WORKSTACK_EVENT_PHASE_COMPLETED"
            }
            WorkstackEventType::WorkstackEventPhaseFailed => {
                "WORKSTACK_EVENT_PHASE_FAILED"
            }
            WorkstackEventType::WorkstackEventPhaseSkipped => {
                "WORKSTACK_EVENT_PHASE_SKIPPED"
            }
            WorkstackEventType::WorkstackEventCompleted => "WORKSTACK_EVENT_COMPLETED",
            WorkstackEventType::WorkstackEventFailed => "WORKSTACK_EVENT_FAILED",
            WorkstackEventType::WorkstackEventRollbackStarted => {
                "WORKSTACK_EVENT_ROLLBACK_STARTED"
            }
            WorkstackEventType::WorkstackEventRollbackCompleted => {
                "WORKSTACK_EVENT_ROLLBACK_COMPLETED"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKSTACK_EVENT_STARTED" => Some(Self::WorkstackEventStarted),
            "WORKSTACK_EVENT_PHASE_STARTED" => Some(Self::WorkstackEventPhaseStarted),
            "WORKSTACK_EVENT_PHASE_PROGRESS" => Some(Self::WorkstackEventPhaseProgress),
            "WORKSTACK_EVENT_PHASE_COMPLETED" => Some(Self::WorkstackEventPhaseCompleted),
            "WORKSTACK_EVENT_PHASE_FAILED" => Some(Self::WorkstackEventPhaseFailed),
            "WORKSTACK_EVENT_PHASE_SKIPPED" => Some(Self::WorkstackEventPhaseSkipped),
            "WORKSTACK_EVENT_COMPLETED" => Some(Self::WorkstackEventCompleted),
            "WORKSTACK_EVENT_FAILED" => Some(Self::WorkstackEventFailed),
            "WORKSTACK_EVENT_ROLLBACK_STARTED" => {
                Some(Self::WorkstackEventRollbackStarted)
            }
            "WORKSTACK_EVENT_ROLLBACK_COMPLETED" => {
                Some(Self::WorkstackEventRollbackCompleted)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkstackExecutionStatus {
    WorkstackExecutionPending = 0,
    WorkstackExecutionRunning = 1,
    WorkstackExecutionCompleted = 2,
    WorkstackExecutionFailed = 3,
    WorkstackExecutionCancelled = 4,
    WorkstackExecutionRollingBack = 5,
    WorkstackExecutionRolledBack = 6,
}
impl WorkstackExecutionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            WorkstackExecutionStatus::WorkstackExecutionPending => {
                "WORKSTACK_EXECUTION_PENDING"
            }
            WorkstackExecutionStatus::WorkstackExecutionRunning => {
                "WORKSTACK_EXECUTION_RUNNING"
            }
            WorkstackExecutionStatus::WorkstackExecutionCompleted => {
                "WORKSTACK_EXECUTION_COMPLETED"
            }
            WorkstackExecutionStatus::WorkstackExecutionFailed => {
                "WORKSTACK_EXECUTION_FAILED"
            }
            WorkstackExecutionStatus::WorkstackExecutionCancelled => {
                "WORKSTACK_EXECUTION_CANCELLED"
            }
            WorkstackExecutionStatus::WorkstackExecutionRollingBack => {
                "WORKSTACK_EXECUTION_ROLLING_BACK"
            }
            WorkstackExecutionStatus::WorkstackExecutionRolledBack => {
                "WORKSTACK_EXECUTION_ROLLED_BACK"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKSTACK_EXECUTION_PENDING" => Some(Self::WorkstackExecutionPending),
            "WORKSTACK_EXECUTION_RUNNING" => Some(Self::WorkstackExecutionRunning),
            "WORKSTACK_EXECUTION_COMPLETED" => Some(Self::WorkstackExecutionCompleted),
            "WORKSTACK_EXECUTION_FAILED" => Some(Self::WorkstackExecutionFailed),
            "WORKSTACK_EXECUTION_CANCELLED" => Some(Self::WorkstackExecutionCancelled),
            "WORKSTACK_EXECUTION_ROLLING_BACK" => {
                Some(Self::WorkstackExecutionRollingBack)
            }
            "WORKSTACK_EXECUTION_ROLLED_BACK" => Some(Self::WorkstackExecutionRolledBack),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod agent_lifecycle_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Manages agent lifecycle (start/stop/health)
    #[derive(Debug, Clone)]
    pub struct AgentLifecycleClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AgentLifecycleClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AgentLifecycleClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AgentLifecycleClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            AgentLifecycleClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Start a session and run-on-connection agents
        pub async fn start_session(
            &mut self,
            request: impl tonic::IntoRequest<super::StartSessionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartSessionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.AgentLifecycle/StartSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.AgentLifecycle",
                        "StartSession",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// End a session and cleanup agents
        pub async fn end_session(
            &mut self,
            request: impl tonic::IntoRequest<super::EndSessionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EndSessionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.AgentLifecycle/EndSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.AgentLifecycle", "EndSession"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Health check for an agent
        pub async fn health_check(
            &mut self,
            request: impl tonic::IntoRequest<super::HealthCheckRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HealthCheckResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.AgentLifecycle/HealthCheck",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.AgentLifecycle",
                        "HealthCheck",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Watch agent status changes (server streaming)
        pub async fn watch_agents(
            &mut self,
            request: impl tonic::IntoRequest<super::WatchAgentsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::AgentStatusEvent>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.AgentLifecycle/WatchAgents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.AgentLifecycle",
                        "WatchAgents",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Graceful shutdown of all agents
        pub async fn shutdown(
            &mut self,
            request: impl tonic::IntoRequest<super::ShutdownRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ShutdownResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.AgentLifecycle/Shutdown",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.AgentLifecycle", "Shutdown"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod agent_execution_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Execute operations on agents
    #[derive(Debug, Clone)]
    pub struct AgentExecutionClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AgentExecutionClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AgentExecutionClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AgentExecutionClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            AgentExecutionClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Execute a single operation
        pub async fn execute(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecuteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecuteResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.AgentExecution/Execute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.AgentExecution", "Execute"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Execute with streaming response (for long-running ops)
        pub async fn execute_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecuteRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ExecuteChunk>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.AgentExecution/ExecuteStream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.AgentExecution",
                        "ExecuteStream",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Batch execute multiple operations
        pub async fn batch_execute(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchExecuteRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ExecuteResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.AgentExecution/BatchExecute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.AgentExecution",
                        "BatchExecute",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Cancel a running operation
        pub async fn cancel(
            &mut self,
            request: impl tonic::IntoRequest<super::CancelRequest>,
        ) -> std::result::Result<tonic::Response<super::CancelResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.AgentExecution/Cancel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.AgentExecution", "Cancel"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod memory_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct MemoryServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MemoryServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MemoryServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MemoryServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            MemoryServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn remember(
            &mut self,
            request: impl tonic::IntoRequest<super::RememberRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RememberResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.MemoryService/Remember",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.MemoryService", "Remember"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn recall(
            &mut self,
            request: impl tonic::IntoRequest<super::RecallRequest>,
        ) -> std::result::Result<tonic::Response<super::RecallResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.MemoryService/Recall",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.MemoryService", "Recall"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn forget(
            &mut self,
            request: impl tonic::IntoRequest<super::ForgetRequest>,
        ) -> std::result::Result<tonic::Response<super::ForgetResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.MemoryService/Forget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.MemoryService", "Forget"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListKeysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.MemoryService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("op_chat.orchestration.MemoryService", "List"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn search(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchMemoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchMemoryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.MemoryService/Search",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.MemoryService", "Search"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Bulk operations for efficiency
        pub async fn bulk_remember(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::RememberRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BulkOperationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.MemoryService/BulkRemember",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.MemoryService",
                        "BulkRemember",
                    ),
                );
            self.inner.client_streaming(req, path, codec).await
        }
        pub async fn bulk_recall(
            &mut self,
            request: impl tonic::IntoRequest<super::BulkRecallRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::RecallResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.MemoryService/BulkRecall",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.MemoryService", "BulkRecall"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn bulk_forget(
            &mut self,
            request: impl tonic::IntoRequest<super::BulkForgetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BulkOperationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.MemoryService/BulkForget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.MemoryService", "BulkForget"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod sequential_thinking_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct SequentialThinkingServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SequentialThinkingServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SequentialThinkingServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SequentialThinkingServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            SequentialThinkingServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Start a thinking chain
        pub async fn start_chain(
            &mut self,
            request: impl tonic::IntoRequest<super::StartChainRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartChainResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.SequentialThinkingService/StartChain",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.SequentialThinkingService",
                        "StartChain",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Add a thought to the chain
        pub async fn add_thought(
            &mut self,
            request: impl tonic::IntoRequest<super::AddThoughtRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddThoughtResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.SequentialThinkingService/AddThought",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.SequentialThinkingService",
                        "AddThought",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Stream the thinking process
        pub async fn think_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::StartChainRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ThoughtEvent>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.SequentialThinkingService/ThinkStream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.SequentialThinkingService",
                        "ThinkStream",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Conclude the chain
        pub async fn conclude(
            &mut self,
            request: impl tonic::IntoRequest<super::ConcludeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConcludeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.SequentialThinkingService/Conclude",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.SequentialThinkingService",
                        "Conclude",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get chain history
        pub async fn get_chain(
            &mut self,
            request: impl tonic::IntoRequest<super::GetChainRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetChainResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.SequentialThinkingService/GetChain",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.SequentialThinkingService",
                        "GetChain",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Fork a chain for alternative exploration
        pub async fn fork_chain(
            &mut self,
            request: impl tonic::IntoRequest<super::ForkChainRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ForkChainResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.SequentialThinkingService/ForkChain",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.SequentialThinkingService",
                        "ForkChain",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod context_manager_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct ContextManagerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ContextManagerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ContextManagerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ContextManagerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ContextManagerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn save(
            &mut self,
            request: impl tonic::IntoRequest<super::SaveContextRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SaveContextResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.ContextManagerService/Save",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.ContextManagerService",
                        "Save",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn load(
            &mut self,
            request: impl tonic::IntoRequest<super::LoadContextRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LoadContextResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.ContextManagerService/Load",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.ContextManagerService",
                        "Load",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListContextsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListContextsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.ContextManagerService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.ContextManagerService",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteContextRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteContextResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.ContextManagerService/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.ContextManagerService",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn export(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportContextRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ExportChunk>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.ContextManagerService/Export",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.ContextManagerService",
                        "Export",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn import(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::ImportChunk>,
        ) -> std::result::Result<
            tonic::Response<super::ImportContextResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.ContextManagerService/Import",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.ContextManagerService",
                        "Import",
                    ),
                );
            self.inner.client_streaming(req, path, codec).await
        }
        pub async fn merge(
            &mut self,
            request: impl tonic::IntoRequest<super::MergeContextsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MergeContextsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.ContextManagerService/Merge",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.ContextManagerService",
                        "Merge",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod rust_pro_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct RustProServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl RustProServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> RustProServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RustProServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RustProServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Quick operations (non-streaming)
        pub async fn check(
            &mut self,
            request: impl tonic::IntoRequest<super::CargoRequest>,
        ) -> std::result::Result<tonic::Response<super::CargoResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.RustProService/Check",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.RustProService", "Check"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn fmt(
            &mut self,
            request: impl tonic::IntoRequest<super::CargoRequest>,
        ) -> std::result::Result<tonic::Response<super::CargoResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.RustProService/Fmt",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("op_chat.orchestration.RustProService", "Fmt"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn version(
            &mut self,
            request: impl tonic::IntoRequest<super::VersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VersionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.RustProService/Version",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.RustProService", "Version"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Streaming operations
        pub async fn build(
            &mut self,
            request: impl tonic::IntoRequest<super::CargoRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::CargoOutputLine>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.RustProService/Build",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.RustProService", "Build"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn test(
            &mut self,
            request: impl tonic::IntoRequest<super::CargoRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::CargoOutputLine>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.RustProService/Test",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("op_chat.orchestration.RustProService", "Test"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn clippy(
            &mut self,
            request: impl tonic::IntoRequest<super::CargoRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::CargoOutputLine>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.RustProService/Clippy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.RustProService", "Clippy"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn run(
            &mut self,
            request: impl tonic::IntoRequest<super::CargoRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::CargoOutputLine>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.RustProService/Run",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("op_chat.orchestration.RustProService", "Run"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn doc(
            &mut self,
            request: impl tonic::IntoRequest<super::CargoRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::CargoOutputLine>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.RustProService/Doc",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("op_chat.orchestration.RustProService", "Doc"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn bench(
            &mut self,
            request: impl tonic::IntoRequest<super::CargoRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::CargoOutputLine>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.RustProService/Bench",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.RustProService", "Bench"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Analysis
        pub async fn analyze(
            &mut self,
            request: impl tonic::IntoRequest<super::AnalyzeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AnalyzeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.RustProService/Analyze",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.RustProService", "Analyze"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod backend_architect_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct BackendArchitectServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BackendArchitectServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BackendArchitectServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BackendArchitectServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            BackendArchitectServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn analyze(
            &mut self,
            request: impl tonic::IntoRequest<super::ArchitectAnalyzeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ArchitectAnalyzeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.BackendArchitectService/Analyze",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.BackendArchitectService",
                        "Analyze",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn design(
            &mut self,
            request: impl tonic::IntoRequest<super::ArchitectDesignRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ArchitectDesignResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.BackendArchitectService/Design",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.BackendArchitectService",
                        "Design",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn review(
            &mut self,
            request: impl tonic::IntoRequest<super::ArchitectReviewRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ArchitectReviewResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.BackendArchitectService/Review",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.BackendArchitectService",
                        "Review",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn suggest(
            &mut self,
            request: impl tonic::IntoRequest<super::ArchitectSuggestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ArchitectSuggestResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.BackendArchitectService/Suggest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.BackendArchitectService",
                        "Suggest",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn document(
            &mut self,
            request: impl tonic::IntoRequest<super::ArchitectDocumentRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::DocumentChunk>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.BackendArchitectService/Document",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.BackendArchitectService",
                        "Document",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod workstack_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct WorkstackServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WorkstackServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WorkstackServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WorkstackServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            WorkstackServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Execute a workstack
        pub async fn execute(
            &mut self,
            request: impl tonic::IntoRequest<super::WorkstackExecuteRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::WorkstackEvent>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.WorkstackService/Execute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.WorkstackService", "Execute"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Get workstack status
        pub async fn get_status(
            &mut self,
            request: impl tonic::IntoRequest<super::WorkstackStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::WorkstackStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.WorkstackService/GetStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "op_chat.orchestration.WorkstackService",
                        "GetStatus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Cancel a running workstack
        pub async fn cancel(
            &mut self,
            request: impl tonic::IntoRequest<super::WorkstackCancelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::WorkstackCancelResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.WorkstackService/Cancel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.WorkstackService", "Cancel"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Rollback a workstack
        pub async fn rollback(
            &mut self,
            request: impl tonic::IntoRequest<super::WorkstackRollbackRequest>,
        ) -> std::result::Result<
            tonic::Response<super::WorkstackRollbackResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.WorkstackService/Rollback",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.WorkstackService", "Rollback"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List available workstacks
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListWorkstacksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListWorkstacksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/op_chat.orchestration.WorkstackService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("op_chat.orchestration.WorkstackService", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod agent_lifecycle_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AgentLifecycleServer.
    #[async_trait]
    pub trait AgentLifecycle: Send + Sync + 'static {
        /// Start a session and run-on-connection agents
        async fn start_session(
            &self,
            request: tonic::Request<super::StartSessionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartSessionResponse>,
            tonic::Status,
        >;
        /// End a session and cleanup agents
        async fn end_session(
            &self,
            request: tonic::Request<super::EndSessionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EndSessionResponse>,
            tonic::Status,
        >;
        /// Health check for an agent
        async fn health_check(
            &self,
            request: tonic::Request<super::HealthCheckRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HealthCheckResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the WatchAgents method.
        type WatchAgentsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::AgentStatusEvent, tonic::Status>,
            >
            + Send
            + 'static;
        /// Watch agent status changes (server streaming)
        async fn watch_agents(
            &self,
            request: tonic::Request<super::WatchAgentsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::WatchAgentsStream>,
            tonic::Status,
        >;
        /// Graceful shutdown of all agents
        async fn shutdown(
            &self,
            request: tonic::Request<super::ShutdownRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ShutdownResponse>,
            tonic::Status,
        >;
    }
    /// Manages agent lifecycle (start/stop/health)
    #[derive(Debug)]
    pub struct AgentLifecycleServer<T: AgentLifecycle> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: AgentLifecycle> AgentLifecycleServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AgentLifecycleServer<T>
    where
        T: AgentLifecycle,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/op_chat.orchestration.AgentLifecycle/StartSession" => {
                    #[allow(non_camel_case_types)]
                    struct StartSessionSvc<T: AgentLifecycle>(pub Arc<T>);
                    impl<
                        T: AgentLifecycle,
                    > tonic::server::UnaryService<super::StartSessionRequest>
                    for StartSessionSvc<T> {
                        type Response = super::StartSessionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartSessionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AgentLifecycle>::start_session(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = StartSessionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.AgentLifecycle/EndSession" => {
                    #[allow(non_camel_case_types)]
                    struct EndSessionSvc<T: AgentLifecycle>(pub Arc<T>);
                    impl<
                        T: AgentLifecycle,
                    > tonic::server::UnaryService<super::EndSessionRequest>
                    for EndSessionSvc<T> {
                        type Response = super::EndSessionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EndSessionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AgentLifecycle>::end_session(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = EndSessionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.AgentLifecycle/HealthCheck" => {
                    #[allow(non_camel_case_types)]
                    struct HealthCheckSvc<T: AgentLifecycle>(pub Arc<T>);
                    impl<
                        T: AgentLifecycle,
                    > tonic::server::UnaryService<super::HealthCheckRequest>
                    for HealthCheckSvc<T> {
                        type Response = super::HealthCheckResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HealthCheckRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AgentLifecycle>::health_check(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = HealthCheckSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.AgentLifecycle/WatchAgents" => {
                    #[allow(non_camel_case_types)]
                    struct WatchAgentsSvc<T: AgentLifecycle>(pub Arc<T>);
                    impl<
                        T: AgentLifecycle,
                    > tonic::server::ServerStreamingService<super::WatchAgentsRequest>
                    for WatchAgentsSvc<T> {
                        type Response = super::AgentStatusEvent;
                        type ResponseStream = T::WatchAgentsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WatchAgentsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AgentLifecycle>::watch_agents(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = WatchAgentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.AgentLifecycle/Shutdown" => {
                    #[allow(non_camel_case_types)]
                    struct ShutdownSvc<T: AgentLifecycle>(pub Arc<T>);
                    impl<
                        T: AgentLifecycle,
                    > tonic::server::UnaryService<super::ShutdownRequest>
                    for ShutdownSvc<T> {
                        type Response = super::ShutdownResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ShutdownRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AgentLifecycle>::shutdown(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ShutdownSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: AgentLifecycle> Clone for AgentLifecycleServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: AgentLifecycle> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AgentLifecycle> tonic::server::NamedService for AgentLifecycleServer<T> {
        const NAME: &'static str = "op_chat.orchestration.AgentLifecycle";
    }
}
/// Generated server implementations.
pub mod agent_execution_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AgentExecutionServer.
    #[async_trait]
    pub trait AgentExecution: Send + Sync + 'static {
        /// Execute a single operation
        async fn execute(
            &self,
            request: tonic::Request<super::ExecuteRequest>,
        ) -> std::result::Result<tonic::Response<super::ExecuteResponse>, tonic::Status>;
        /// Server streaming response type for the ExecuteStream method.
        type ExecuteStreamStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ExecuteChunk, tonic::Status>,
            >
            + Send
            + 'static;
        /// Execute with streaming response (for long-running ops)
        async fn execute_stream(
            &self,
            request: tonic::Request<super::ExecuteRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::ExecuteStreamStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the BatchExecute method.
        type BatchExecuteStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ExecuteResponse, tonic::Status>,
            >
            + Send
            + 'static;
        /// Batch execute multiple operations
        async fn batch_execute(
            &self,
            request: tonic::Request<super::BatchExecuteRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::BatchExecuteStream>,
            tonic::Status,
        >;
        /// Cancel a running operation
        async fn cancel(
            &self,
            request: tonic::Request<super::CancelRequest>,
        ) -> std::result::Result<tonic::Response<super::CancelResponse>, tonic::Status>;
    }
    /// Execute operations on agents
    #[derive(Debug)]
    pub struct AgentExecutionServer<T: AgentExecution> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: AgentExecution> AgentExecutionServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AgentExecutionServer<T>
    where
        T: AgentExecution,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/op_chat.orchestration.AgentExecution/Execute" => {
                    #[allow(non_camel_case_types)]
                    struct ExecuteSvc<T: AgentExecution>(pub Arc<T>);
                    impl<
                        T: AgentExecution,
                    > tonic::server::UnaryService<super::ExecuteRequest>
                    for ExecuteSvc<T> {
                        type Response = super::ExecuteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExecuteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AgentExecution>::execute(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ExecuteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.AgentExecution/ExecuteStream" => {
                    #[allow(non_camel_case_types)]
                    struct ExecuteStreamSvc<T: AgentExecution>(pub Arc<T>);
                    impl<
                        T: AgentExecution,
                    > tonic::server::ServerStreamingService<super::ExecuteRequest>
                    for ExecuteStreamSvc<T> {
                        type Response = super::ExecuteChunk;
                        type ResponseStream = T::ExecuteStreamStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExecuteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AgentExecution>::execute_stream(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ExecuteStreamSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.AgentExecution/BatchExecute" => {
                    #[allow(non_camel_case_types)]
                    struct BatchExecuteSvc<T: AgentExecution>(pub Arc<T>);
                    impl<
                        T: AgentExecution,
                    > tonic::server::ServerStreamingService<super::BatchExecuteRequest>
                    for BatchExecuteSvc<T> {
                        type Response = super::ExecuteResponse;
                        type ResponseStream = T::BatchExecuteStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BatchExecuteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AgentExecution>::batch_execute(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = BatchExecuteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.AgentExecution/Cancel" => {
                    #[allow(non_camel_case_types)]
                    struct CancelSvc<T: AgentExecution>(pub Arc<T>);
                    impl<
                        T: AgentExecution,
                    > tonic::server::UnaryService<super::CancelRequest>
                    for CancelSvc<T> {
                        type Response = super::CancelResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CancelRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AgentExecution>::cancel(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CancelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: AgentExecution> Clone for AgentExecutionServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: AgentExecution> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: AgentExecution> tonic::server::NamedService for AgentExecutionServer<T> {
        const NAME: &'static str = "op_chat.orchestration.AgentExecution";
    }
}
/// Generated server implementations.
pub mod memory_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with MemoryServiceServer.
    #[async_trait]
    pub trait MemoryService: Send + Sync + 'static {
        async fn remember(
            &self,
            request: tonic::Request<super::RememberRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RememberResponse>,
            tonic::Status,
        >;
        async fn recall(
            &self,
            request: tonic::Request<super::RecallRequest>,
        ) -> std::result::Result<tonic::Response<super::RecallResponse>, tonic::Status>;
        async fn forget(
            &self,
            request: tonic::Request<super::ForgetRequest>,
        ) -> std::result::Result<tonic::Response<super::ForgetResponse>, tonic::Status>;
        async fn list(
            &self,
            request: tonic::Request<super::ListKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListKeysResponse>,
            tonic::Status,
        >;
        async fn search(
            &self,
            request: tonic::Request<super::SearchMemoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchMemoryResponse>,
            tonic::Status,
        >;
        /// Bulk operations for efficiency
        async fn bulk_remember(
            &self,
            request: tonic::Request<tonic::Streaming<super::RememberRequest>>,
        ) -> std::result::Result<
            tonic::Response<super::BulkOperationResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the BulkRecall method.
        type BulkRecallStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::RecallResponse, tonic::Status>,
            >
            + Send
            + 'static;
        async fn bulk_recall(
            &self,
            request: tonic::Request<super::BulkRecallRequest>,
        ) -> std::result::Result<tonic::Response<Self::BulkRecallStream>, tonic::Status>;
        async fn bulk_forget(
            &self,
            request: tonic::Request<super::BulkForgetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BulkOperationResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct MemoryServiceServer<T: MemoryService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: MemoryService> MemoryServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for MemoryServiceServer<T>
    where
        T: MemoryService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/op_chat.orchestration.MemoryService/Remember" => {
                    #[allow(non_camel_case_types)]
                    struct RememberSvc<T: MemoryService>(pub Arc<T>);
                    impl<
                        T: MemoryService,
                    > tonic::server::UnaryService<super::RememberRequest>
                    for RememberSvc<T> {
                        type Response = super::RememberResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RememberRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MemoryService>::remember(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = RememberSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.MemoryService/Recall" => {
                    #[allow(non_camel_case_types)]
                    struct RecallSvc<T: MemoryService>(pub Arc<T>);
                    impl<
                        T: MemoryService,
                    > tonic::server::UnaryService<super::RecallRequest>
                    for RecallSvc<T> {
                        type Response = super::RecallResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RecallRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MemoryService>::recall(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = RecallSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.MemoryService/Forget" => {
                    #[allow(non_camel_case_types)]
                    struct ForgetSvc<T: MemoryService>(pub Arc<T>);
                    impl<
                        T: MemoryService,
                    > tonic::server::UnaryService<super::ForgetRequest>
                    for ForgetSvc<T> {
                        type Response = super::ForgetResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ForgetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MemoryService>::forget(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ForgetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.MemoryService/List" => {
                    #[allow(non_camel_case_types)]
                    struct ListSvc<T: MemoryService>(pub Arc<T>);
                    impl<
                        T: MemoryService,
                    > tonic::server::UnaryService<super::ListKeysRequest>
                    for ListSvc<T> {
                        type Response = super::ListKeysResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListKeysRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MemoryService>::list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.MemoryService/Search" => {
                    #[allow(non_camel_case_types)]
                    struct SearchSvc<T: MemoryService>(pub Arc<T>);
                    impl<
                        T: MemoryService,
                    > tonic::server::UnaryService<super::SearchMemoryRequest>
                    for SearchSvc<T> {
                        type Response = super::SearchMemoryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SearchMemoryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MemoryService>::search(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = SearchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.MemoryService/BulkRemember" => {
                    #[allow(non_camel_case_types)]
                    struct BulkRememberSvc<T: MemoryService>(pub Arc<T>);
                    impl<
                        T: MemoryService,
                    > tonic::server::ClientStreamingService<super::RememberRequest>
                    for BulkRememberSvc<T> {
                        type Response = super::BulkOperationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::RememberRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MemoryService>::bulk_remember(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = BulkRememberSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.client_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.MemoryService/BulkRecall" => {
                    #[allow(non_camel_case_types)]
                    struct BulkRecallSvc<T: MemoryService>(pub Arc<T>);
                    impl<
                        T: MemoryService,
                    > tonic::server::ServerStreamingService<super::BulkRecallRequest>
                    for BulkRecallSvc<T> {
                        type Response = super::RecallResponse;
                        type ResponseStream = T::BulkRecallStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BulkRecallRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MemoryService>::bulk_recall(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = BulkRecallSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.MemoryService/BulkForget" => {
                    #[allow(non_camel_case_types)]
                    struct BulkForgetSvc<T: MemoryService>(pub Arc<T>);
                    impl<
                        T: MemoryService,
                    > tonic::server::UnaryService<super::BulkForgetRequest>
                    for BulkForgetSvc<T> {
                        type Response = super::BulkOperationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BulkForgetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MemoryService>::bulk_forget(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = BulkForgetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: MemoryService> Clone for MemoryServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: MemoryService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: MemoryService> tonic::server::NamedService for MemoryServiceServer<T> {
        const NAME: &'static str = "op_chat.orchestration.MemoryService";
    }
}
/// Generated server implementations.
pub mod sequential_thinking_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SequentialThinkingServiceServer.
    #[async_trait]
    pub trait SequentialThinkingService: Send + Sync + 'static {
        /// Start a thinking chain
        async fn start_chain(
            &self,
            request: tonic::Request<super::StartChainRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartChainResponse>,
            tonic::Status,
        >;
        /// Add a thought to the chain
        async fn add_thought(
            &self,
            request: tonic::Request<super::AddThoughtRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddThoughtResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the ThinkStream method.
        type ThinkStreamStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ThoughtEvent, tonic::Status>,
            >
            + Send
            + 'static;
        /// Stream the thinking process
        async fn think_stream(
            &self,
            request: tonic::Request<super::StartChainRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::ThinkStreamStream>,
            tonic::Status,
        >;
        /// Conclude the chain
        async fn conclude(
            &self,
            request: tonic::Request<super::ConcludeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConcludeResponse>,
            tonic::Status,
        >;
        /// Get chain history
        async fn get_chain(
            &self,
            request: tonic::Request<super::GetChainRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetChainResponse>,
            tonic::Status,
        >;
        /// Fork a chain for alternative exploration
        async fn fork_chain(
            &self,
            request: tonic::Request<super::ForkChainRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ForkChainResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct SequentialThinkingServiceServer<T: SequentialThinkingService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: SequentialThinkingService> SequentialThinkingServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for SequentialThinkingServiceServer<T>
    where
        T: SequentialThinkingService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/op_chat.orchestration.SequentialThinkingService/StartChain" => {
                    #[allow(non_camel_case_types)]
                    struct StartChainSvc<T: SequentialThinkingService>(pub Arc<T>);
                    impl<
                        T: SequentialThinkingService,
                    > tonic::server::UnaryService<super::StartChainRequest>
                    for StartChainSvc<T> {
                        type Response = super::StartChainResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartChainRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SequentialThinkingService>::start_chain(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = StartChainSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.SequentialThinkingService/AddThought" => {
                    #[allow(non_camel_case_types)]
                    struct AddThoughtSvc<T: SequentialThinkingService>(pub Arc<T>);
                    impl<
                        T: SequentialThinkingService,
                    > tonic::server::UnaryService<super::AddThoughtRequest>
                    for AddThoughtSvc<T> {
                        type Response = super::AddThoughtResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddThoughtRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SequentialThinkingService>::add_thought(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = AddThoughtSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.SequentialThinkingService/ThinkStream" => {
                    #[allow(non_camel_case_types)]
                    struct ThinkStreamSvc<T: SequentialThinkingService>(pub Arc<T>);
                    impl<
                        T: SequentialThinkingService,
                    > tonic::server::ServerStreamingService<super::StartChainRequest>
                    for ThinkStreamSvc<T> {
                        type Response = super::ThoughtEvent;
                        type ResponseStream = T::ThinkStreamStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartChainRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SequentialThinkingService>::think_stream(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ThinkStreamSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.SequentialThinkingService/Conclude" => {
                    #[allow(non_camel_case_types)]
                    struct ConcludeSvc<T: SequentialThinkingService>(pub Arc<T>);
                    impl<
                        T: SequentialThinkingService,
                    > tonic::server::UnaryService<super::ConcludeRequest>
                    for ConcludeSvc<T> {
                        type Response = super::ConcludeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ConcludeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SequentialThinkingService>::conclude(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ConcludeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.SequentialThinkingService/GetChain" => {
                    #[allow(non_camel_case_types)]
                    struct GetChainSvc<T: SequentialThinkingService>(pub Arc<T>);
                    impl<
                        T: SequentialThinkingService,
                    > tonic::server::UnaryService<super::GetChainRequest>
                    for GetChainSvc<T> {
                        type Response = super::GetChainResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetChainRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SequentialThinkingService>::get_chain(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetChainSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.SequentialThinkingService/ForkChain" => {
                    #[allow(non_camel_case_types)]
                    struct ForkChainSvc<T: SequentialThinkingService>(pub Arc<T>);
                    impl<
                        T: SequentialThinkingService,
                    > tonic::server::UnaryService<super::ForkChainRequest>
                    for ForkChainSvc<T> {
                        type Response = super::ForkChainResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ForkChainRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SequentialThinkingService>::fork_chain(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ForkChainSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: SequentialThinkingService> Clone for SequentialThinkingServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: SequentialThinkingService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: SequentialThinkingService> tonic::server::NamedService
    for SequentialThinkingServiceServer<T> {
        const NAME: &'static str = "op_chat.orchestration.SequentialThinkingService";
    }
}
/// Generated server implementations.
pub mod context_manager_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ContextManagerServiceServer.
    #[async_trait]
    pub trait ContextManagerService: Send + Sync + 'static {
        async fn save(
            &self,
            request: tonic::Request<super::SaveContextRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SaveContextResponse>,
            tonic::Status,
        >;
        async fn load(
            &self,
            request: tonic::Request<super::LoadContextRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LoadContextResponse>,
            tonic::Status,
        >;
        async fn list(
            &self,
            request: tonic::Request<super::ListContextsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListContextsResponse>,
            tonic::Status,
        >;
        async fn delete(
            &self,
            request: tonic::Request<super::DeleteContextRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteContextResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the Export method.
        type ExportStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ExportChunk, tonic::Status>,
            >
            + Send
            + 'static;
        async fn export(
            &self,
            request: tonic::Request<super::ExportContextRequest>,
        ) -> std::result::Result<tonic::Response<Self::ExportStream>, tonic::Status>;
        async fn import(
            &self,
            request: tonic::Request<tonic::Streaming<super::ImportChunk>>,
        ) -> std::result::Result<
            tonic::Response<super::ImportContextResponse>,
            tonic::Status,
        >;
        async fn merge(
            &self,
            request: tonic::Request<super::MergeContextsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MergeContextsResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct ContextManagerServiceServer<T: ContextManagerService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: ContextManagerService> ContextManagerServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for ContextManagerServiceServer<T>
    where
        T: ContextManagerService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/op_chat.orchestration.ContextManagerService/Save" => {
                    #[allow(non_camel_case_types)]
                    struct SaveSvc<T: ContextManagerService>(pub Arc<T>);
                    impl<
                        T: ContextManagerService,
                    > tonic::server::UnaryService<super::SaveContextRequest>
                    for SaveSvc<T> {
                        type Response = super::SaveContextResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SaveContextRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ContextManagerService>::save(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = SaveSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.ContextManagerService/Load" => {
                    #[allow(non_camel_case_types)]
                    struct LoadSvc<T: ContextManagerService>(pub Arc<T>);
                    impl<
                        T: ContextManagerService,
                    > tonic::server::UnaryService<super::LoadContextRequest>
                    for LoadSvc<T> {
                        type Response = super::LoadContextResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LoadContextRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ContextManagerService>::load(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = LoadSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.ContextManagerService/List" => {
                    #[allow(non_camel_case_types)]
                    struct ListSvc<T: ContextManagerService>(pub Arc<T>);
                    impl<
                        T: ContextManagerService,
                    > tonic::server::UnaryService<super::ListContextsRequest>
                    for ListSvc<T> {
                        type Response = super::ListContextsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListContextsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ContextManagerService>::list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.ContextManagerService/Delete" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteSvc<T: ContextManagerService>(pub Arc<T>);
                    impl<
                        T: ContextManagerService,
                    > tonic::server::UnaryService<super::DeleteContextRequest>
                    for DeleteSvc<T> {
                        type Response = super::DeleteContextResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteContextRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ContextManagerService>::delete(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeleteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.ContextManagerService/Export" => {
                    #[allow(non_camel_case_types)]
                    struct ExportSvc<T: ContextManagerService>(pub Arc<T>);
                    impl<
                        T: ContextManagerService,
                    > tonic::server::ServerStreamingService<super::ExportContextRequest>
                    for ExportSvc<T> {
                        type Response = super::ExportChunk;
                        type ResponseStream = T::ExportStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExportContextRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ContextManagerService>::export(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ExportSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.ContextManagerService/Import" => {
                    #[allow(non_camel_case_types)]
                    struct ImportSvc<T: ContextManagerService>(pub Arc<T>);
                    impl<
                        T: ContextManagerService,
                    > tonic::server::ClientStreamingService<super::ImportChunk>
                    for ImportSvc<T> {
                        type Response = super::ImportContextResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<tonic::Streaming<super::ImportChunk>>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ContextManagerService>::import(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ImportSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.client_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.ContextManagerService/Merge" => {
                    #[allow(non_camel_case_types)]
                    struct MergeSvc<T: ContextManagerService>(pub Arc<T>);
                    impl<
                        T: ContextManagerService,
                    > tonic::server::UnaryService<super::MergeContextsRequest>
                    for MergeSvc<T> {
                        type Response = super::MergeContextsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MergeContextsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ContextManagerService>::merge(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = MergeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: ContextManagerService> Clone for ContextManagerServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: ContextManagerService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: ContextManagerService> tonic::server::NamedService
    for ContextManagerServiceServer<T> {
        const NAME: &'static str = "op_chat.orchestration.ContextManagerService";
    }
}
/// Generated server implementations.
pub mod rust_pro_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with RustProServiceServer.
    #[async_trait]
    pub trait RustProService: Send + Sync + 'static {
        /// Quick operations (non-streaming)
        async fn check(
            &self,
            request: tonic::Request<super::CargoRequest>,
        ) -> std::result::Result<tonic::Response<super::CargoResponse>, tonic::Status>;
        async fn fmt(
            &self,
            request: tonic::Request<super::CargoRequest>,
        ) -> std::result::Result<tonic::Response<super::CargoResponse>, tonic::Status>;
        async fn version(
            &self,
            request: tonic::Request<super::VersionRequest>,
        ) -> std::result::Result<tonic::Response<super::VersionResponse>, tonic::Status>;
        /// Server streaming response type for the Build method.
        type BuildStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::CargoOutputLine, tonic::Status>,
            >
            + Send
            + 'static;
        /// Streaming operations
        async fn build(
            &self,
            request: tonic::Request<super::CargoRequest>,
        ) -> std::result::Result<tonic::Response<Self::BuildStream>, tonic::Status>;
        /// Server streaming response type for the Test method.
        type TestStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::CargoOutputLine, tonic::Status>,
            >
            + Send
            + 'static;
        async fn test(
            &self,
            request: tonic::Request<super::CargoRequest>,
        ) -> std::result::Result<tonic::Response<Self::TestStream>, tonic::Status>;
        /// Server streaming response type for the Clippy method.
        type ClippyStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::CargoOutputLine, tonic::Status>,
            >
            + Send
            + 'static;
        async fn clippy(
            &self,
            request: tonic::Request<super::CargoRequest>,
        ) -> std::result::Result<tonic::Response<Self::ClippyStream>, tonic::Status>;
        /// Server streaming response type for the Run method.
        type RunStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::CargoOutputLine, tonic::Status>,
            >
            + Send
            + 'static;
        async fn run(
            &self,
            request: tonic::Request<super::CargoRequest>,
        ) -> std::result::Result<tonic::Response<Self::RunStream>, tonic::Status>;
        /// Server streaming response type for the Doc method.
        type DocStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::CargoOutputLine, tonic::Status>,
            >
            + Send
            + 'static;
        async fn doc(
            &self,
            request: tonic::Request<super::CargoRequest>,
        ) -> std::result::Result<tonic::Response<Self::DocStream>, tonic::Status>;
        /// Server streaming response type for the Bench method.
        type BenchStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::CargoOutputLine, tonic::Status>,
            >
            + Send
            + 'static;
        async fn bench(
            &self,
            request: tonic::Request<super::CargoRequest>,
        ) -> std::result::Result<tonic::Response<Self::BenchStream>, tonic::Status>;
        /// Analysis
        async fn analyze(
            &self,
            request: tonic::Request<super::AnalyzeRequest>,
        ) -> std::result::Result<tonic::Response<super::AnalyzeResponse>, tonic::Status>;
    }
    #[derive(Debug)]
    pub struct RustProServiceServer<T: RustProService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: RustProService> RustProServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for RustProServiceServer<T>
    where
        T: RustProService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/op_chat.orchestration.RustProService/Check" => {
                    #[allow(non_camel_case_types)]
                    struct CheckSvc<T: RustProService>(pub Arc<T>);
                    impl<
                        T: RustProService,
                    > tonic::server::UnaryService<super::CargoRequest> for CheckSvc<T> {
                        type Response = super::CargoResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CargoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RustProService>::check(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CheckSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.RustProService/Fmt" => {
                    #[allow(non_camel_case_types)]
                    struct FmtSvc<T: RustProService>(pub Arc<T>);
                    impl<
                        T: RustProService,
                    > tonic::server::UnaryService<super::CargoRequest> for FmtSvc<T> {
                        type Response = super::CargoResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CargoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RustProService>::fmt(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = FmtSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.RustProService/Version" => {
                    #[allow(non_camel_case_types)]
                    struct VersionSvc<T: RustProService>(pub Arc<T>);
                    impl<
                        T: RustProService,
                    > tonic::server::UnaryService<super::VersionRequest>
                    for VersionSvc<T> {
                        type Response = super::VersionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VersionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RustProService>::version(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VersionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.RustProService/Build" => {
                    #[allow(non_camel_case_types)]
                    struct BuildSvc<T: RustProService>(pub Arc<T>);
                    impl<
                        T: RustProService,
                    > tonic::server::ServerStreamingService<super::CargoRequest>
                    for BuildSvc<T> {
                        type Response = super::CargoOutputLine;
                        type ResponseStream = T::BuildStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CargoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RustProService>::build(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = BuildSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.RustProService/Test" => {
                    #[allow(non_camel_case_types)]
                    struct TestSvc<T: RustProService>(pub Arc<T>);
                    impl<
                        T: RustProService,
                    > tonic::server::ServerStreamingService<super::CargoRequest>
                    for TestSvc<T> {
                        type Response = super::CargoOutputLine;
                        type ResponseStream = T::TestStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CargoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RustProService>::test(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = TestSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.RustProService/Clippy" => {
                    #[allow(non_camel_case_types)]
                    struct ClippySvc<T: RustProService>(pub Arc<T>);
                    impl<
                        T: RustProService,
                    > tonic::server::ServerStreamingService<super::CargoRequest>
                    for ClippySvc<T> {
                        type Response = super::CargoOutputLine;
                        type ResponseStream = T::ClippyStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CargoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RustProService>::clippy(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ClippySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.RustProService/Run" => {
                    #[allow(non_camel_case_types)]
                    struct RunSvc<T: RustProService>(pub Arc<T>);
                    impl<
                        T: RustProService,
                    > tonic::server::ServerStreamingService<super::CargoRequest>
                    for RunSvc<T> {
                        type Response = super::CargoOutputLine;
                        type ResponseStream = T::RunStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CargoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RustProService>::run(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = RunSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.RustProService/Doc" => {
                    #[allow(non_camel_case_types)]
                    struct DocSvc<T: RustProService>(pub Arc<T>);
                    impl<
                        T: RustProService,
                    > tonic::server::ServerStreamingService<super::CargoRequest>
                    for DocSvc<T> {
                        type Response = super::CargoOutputLine;
                        type ResponseStream = T::DocStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CargoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RustProService>::doc(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DocSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.RustProService/Bench" => {
                    #[allow(non_camel_case_types)]
                    struct BenchSvc<T: RustProService>(pub Arc<T>);
                    impl<
                        T: RustProService,
                    > tonic::server::ServerStreamingService<super::CargoRequest>
                    for BenchSvc<T> {
                        type Response = super::CargoOutputLine;
                        type ResponseStream = T::BenchStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CargoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RustProService>::bench(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = BenchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.RustProService/Analyze" => {
                    #[allow(non_camel_case_types)]
                    struct AnalyzeSvc<T: RustProService>(pub Arc<T>);
                    impl<
                        T: RustProService,
                    > tonic::server::UnaryService<super::AnalyzeRequest>
                    for AnalyzeSvc<T> {
                        type Response = super::AnalyzeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AnalyzeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RustProService>::analyze(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = AnalyzeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: RustProService> Clone for RustProServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: RustProService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: RustProService> tonic::server::NamedService for RustProServiceServer<T> {
        const NAME: &'static str = "op_chat.orchestration.RustProService";
    }
}
/// Generated server implementations.
pub mod backend_architect_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with BackendArchitectServiceServer.
    #[async_trait]
    pub trait BackendArchitectService: Send + Sync + 'static {
        async fn analyze(
            &self,
            request: tonic::Request<super::ArchitectAnalyzeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ArchitectAnalyzeResponse>,
            tonic::Status,
        >;
        async fn design(
            &self,
            request: tonic::Request<super::ArchitectDesignRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ArchitectDesignResponse>,
            tonic::Status,
        >;
        async fn review(
            &self,
            request: tonic::Request<super::ArchitectReviewRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ArchitectReviewResponse>,
            tonic::Status,
        >;
        async fn suggest(
            &self,
            request: tonic::Request<super::ArchitectSuggestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ArchitectSuggestResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the Document method.
        type DocumentStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::DocumentChunk, tonic::Status>,
            >
            + Send
            + 'static;
        async fn document(
            &self,
            request: tonic::Request<super::ArchitectDocumentRequest>,
        ) -> std::result::Result<tonic::Response<Self::DocumentStream>, tonic::Status>;
    }
    #[derive(Debug)]
    pub struct BackendArchitectServiceServer<T: BackendArchitectService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: BackendArchitectService> BackendArchitectServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for BackendArchitectServiceServer<T>
    where
        T: BackendArchitectService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/op_chat.orchestration.BackendArchitectService/Analyze" => {
                    #[allow(non_camel_case_types)]
                    struct AnalyzeSvc<T: BackendArchitectService>(pub Arc<T>);
                    impl<
                        T: BackendArchitectService,
                    > tonic::server::UnaryService<super::ArchitectAnalyzeRequest>
                    for AnalyzeSvc<T> {
                        type Response = super::ArchitectAnalyzeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ArchitectAnalyzeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendArchitectService>::analyze(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = AnalyzeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.BackendArchitectService/Design" => {
                    #[allow(non_camel_case_types)]
                    struct DesignSvc<T: BackendArchitectService>(pub Arc<T>);
                    impl<
                        T: BackendArchitectService,
                    > tonic::server::UnaryService<super::ArchitectDesignRequest>
                    for DesignSvc<T> {
                        type Response = super::ArchitectDesignResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ArchitectDesignRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendArchitectService>::design(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DesignSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.BackendArchitectService/Review" => {
                    #[allow(non_camel_case_types)]
                    struct ReviewSvc<T: BackendArchitectService>(pub Arc<T>);
                    impl<
                        T: BackendArchitectService,
                    > tonic::server::UnaryService<super::ArchitectReviewRequest>
                    for ReviewSvc<T> {
                        type Response = super::ArchitectReviewResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ArchitectReviewRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendArchitectService>::review(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ReviewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.BackendArchitectService/Suggest" => {
                    #[allow(non_camel_case_types)]
                    struct SuggestSvc<T: BackendArchitectService>(pub Arc<T>);
                    impl<
                        T: BackendArchitectService,
                    > tonic::server::UnaryService<super::ArchitectSuggestRequest>
                    for SuggestSvc<T> {
                        type Response = super::ArchitectSuggestResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ArchitectSuggestRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendArchitectService>::suggest(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = SuggestSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.BackendArchitectService/Document" => {
                    #[allow(non_camel_case_types)]
                    struct DocumentSvc<T: BackendArchitectService>(pub Arc<T>);
                    impl<
                        T: BackendArchitectService,
                    > tonic::server::ServerStreamingService<
                        super::ArchitectDocumentRequest,
                    > for DocumentSvc<T> {
                        type Response = super::DocumentChunk;
                        type ResponseStream = T::DocumentStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ArchitectDocumentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BackendArchitectService>::document(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DocumentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: BackendArchitectService> Clone for BackendArchitectServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: BackendArchitectService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: BackendArchitectService> tonic::server::NamedService
    for BackendArchitectServiceServer<T> {
        const NAME: &'static str = "op_chat.orchestration.BackendArchitectService";
    }
}
/// Generated server implementations.
pub mod workstack_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with WorkstackServiceServer.
    #[async_trait]
    pub trait WorkstackService: Send + Sync + 'static {
        /// Server streaming response type for the Execute method.
        type ExecuteStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::WorkstackEvent, tonic::Status>,
            >
            + Send
            + 'static;
        /// Execute a workstack
        async fn execute(
            &self,
            request: tonic::Request<super::WorkstackExecuteRequest>,
        ) -> std::result::Result<tonic::Response<Self::ExecuteStream>, tonic::Status>;
        /// Get workstack status
        async fn get_status(
            &self,
            request: tonic::Request<super::WorkstackStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::WorkstackStatusResponse>,
            tonic::Status,
        >;
        /// Cancel a running workstack
        async fn cancel(
            &self,
            request: tonic::Request<super::WorkstackCancelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::WorkstackCancelResponse>,
            tonic::Status,
        >;
        /// Rollback a workstack
        async fn rollback(
            &self,
            request: tonic::Request<super::WorkstackRollbackRequest>,
        ) -> std::result::Result<
            tonic::Response<super::WorkstackRollbackResponse>,
            tonic::Status,
        >;
        /// List available workstacks
        async fn list(
            &self,
            request: tonic::Request<super::ListWorkstacksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListWorkstacksResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct WorkstackServiceServer<T: WorkstackService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: WorkstackService> WorkstackServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for WorkstackServiceServer<T>
    where
        T: WorkstackService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/op_chat.orchestration.WorkstackService/Execute" => {
                    #[allow(non_camel_case_types)]
                    struct ExecuteSvc<T: WorkstackService>(pub Arc<T>);
                    impl<
                        T: WorkstackService,
                    > tonic::server::ServerStreamingService<
                        super::WorkstackExecuteRequest,
                    > for ExecuteSvc<T> {
                        type Response = super::WorkstackEvent;
                        type ResponseStream = T::ExecuteStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WorkstackExecuteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WorkstackService>::execute(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ExecuteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.WorkstackService/GetStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetStatusSvc<T: WorkstackService>(pub Arc<T>);
                    impl<
                        T: WorkstackService,
                    > tonic::server::UnaryService<super::WorkstackStatusRequest>
                    for GetStatusSvc<T> {
                        type Response = super::WorkstackStatusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WorkstackStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WorkstackService>::get_status(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.WorkstackService/Cancel" => {
                    #[allow(non_camel_case_types)]
                    struct CancelSvc<T: WorkstackService>(pub Arc<T>);
                    impl<
                        T: WorkstackService,
                    > tonic::server::UnaryService<super::WorkstackCancelRequest>
                    for CancelSvc<T> {
                        type Response = super::WorkstackCancelResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WorkstackCancelRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WorkstackService>::cancel(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CancelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.WorkstackService/Rollback" => {
                    #[allow(non_camel_case_types)]
                    struct RollbackSvc<T: WorkstackService>(pub Arc<T>);
                    impl<
                        T: WorkstackService,
                    > tonic::server::UnaryService<super::WorkstackRollbackRequest>
                    for RollbackSvc<T> {
                        type Response = super::WorkstackRollbackResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WorkstackRollbackRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WorkstackService>::rollback(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = RollbackSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/op_chat.orchestration.WorkstackService/List" => {
                    #[allow(non_camel_case_types)]
                    struct ListSvc<T: WorkstackService>(pub Arc<T>);
                    impl<
                        T: WorkstackService,
                    > tonic::server::UnaryService<super::ListWorkstacksRequest>
                    for ListSvc<T> {
                        type Response = super::ListWorkstacksResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListWorkstacksRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WorkstackService>::list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: WorkstackService> Clone for WorkstackServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: WorkstackService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: WorkstackService> tonic::server::NamedService for WorkstackServiceServer<T> {
        const NAME: &'static str = "op_chat.orchestration.WorkstackService";
    }
}
