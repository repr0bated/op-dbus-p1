//! Resource Registry for MCP
//!
//! Provides documentation resources that can be served via MCP resources.
//! System prompt content is loaded dynamically on each read so it can be
//! refreshed on model changes.

use serde::{Deserialize, Serialize};
use std::env;
use std::path::Path;

const SYSTEM_PROMPT_URI: &str = "docs://system-prompt";
const HF_MODEL_PROMPT_URI: &str = "docs://hf-model-prompt";

/// Resource information for MCP
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceInfo {
    pub uri: String,
    pub name: String,
    pub description: Option<String>,
    pub mime_type: Option<String>,
}

/// Simple resource registry
pub struct ResourceRegistry {
    resources: Vec<ResourceInfo>,
}

impl Default for ResourceRegistry {
    fn default() -> Self {
        Self::new()
    }
}

impl ResourceRegistry {
    /// Create new empty resource registry
    pub fn new() -> Self {
        let resources = vec![
            ResourceInfo {
                uri: SYSTEM_PROMPT_URI.to_string(),
                name: "op-dbus system prompt".to_string(),
                description: Some("System prompt generated by op-chat.".to_string()),
                mime_type: Some("text/plain".to_string()),
            },
            ResourceInfo {
                uri: HF_MODEL_PROMPT_URI.to_string(),
                name: "hf_model_prompt".to_string(),
                description: Some(
                    "Hugging Face model prompt text (combined by the client).".to_string(),
                ),
                mime_type: Some("text/plain".to_string()),
            },
        ];
        Self { resources }
    }

    /// Add a resource to the registry
    pub fn add_resource(&mut self, resource: ResourceInfo) {
        self.resources.push(resource);
    }

    /// List all available resources
    pub fn list_resources(&self) -> &[ResourceInfo] {
        &self.resources
    }

    /// Get a resource by URI (placeholder implementation)
    pub fn get_resource(&self, uri: &str) -> Option<&ResourceInfo> {
        self.resources.iter().find(|r| r.uri == uri)
    }

    /// Read resource content (dynamic implementation)
    pub async fn read_resource(&self, uri: &str) -> Option<String> {
        match uri {
            SYSTEM_PROMPT_URI => Some(load_system_prompt().await),
            HF_MODEL_PROMPT_URI => load_hf_model_prompt(),
            _ => None,
        }
    }
}

async fn load_system_prompt() -> String {
    let msg = op_chat::generate_system_prompt().await;
    msg.content
}

fn load_hf_model_prompt() -> Option<String> {
    let mut parts = Vec::new();

    if let Ok(value) = env::var("OP_MCP_HF_MODEL_PROMPT") {
        let trimmed = value.trim().to_string();
        if !trimmed.is_empty() {
            parts.push(trimmed);
        }
    }

    if let Ok(path) = env::var("OP_MCP_HF_MODEL_PROMPT_FILE") {
        let path = path.trim();
        if !path.is_empty() && Path::new(path).exists() {
            if let Ok(content) = std::fs::read_to_string(path) {
                let trimmed = content.trim().to_string();
                if !trimmed.is_empty() {
                    parts.push(trimmed);
                }
            }
        }
    }

    if parts.is_empty() {
        None
    } else {
        Some(parts.join("\n\n"))
    }
}
