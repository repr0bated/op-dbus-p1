//! Auto-creation of missing plugins based on DBus introspection

use anyhow::Result;
use async_trait::async_trait;
use serde_json::{json, Value};
use std::sync::Arc;
use tokio::sync::RwLock;
use tracing::{debug, info};

use crate::plugin::{BoxedPlugin, Plugin, PluginCapabilities, PluginContext, PluginMetadata};
use crate::state::{DesiredState, StateChange, ValidationResult};

/// Factory for auto-creating plugins
#[derive(Clone)]
pub struct AutoPluginFactory {
    templates: Arc<RwLock<std::collections::HashMap<String, PluginTemplate>>>,
}

/// Template for auto-generated plugins
#[derive(Clone)]
pub struct PluginTemplate {
    pub name_pattern: String,
    pub dbus_service: Option<String>,
    pub capabilities: PluginCapabilities,
}

impl AutoPluginFactory {
    pub fn new() -> Self {
        let mut templates = std::collections::HashMap::new();

        // Built-in templates
        templates.insert(
            "systemd".to_string(),
            PluginTemplate {
                name_pattern: "systemd".to_string(),
                dbus_service: Some("org.freedesktop.systemd1".to_string()),
                capabilities: PluginCapabilities {
                    can_read: true,
                    can_write: true,
                    requires_root: true,
                    ..Default::default()
                },
            },
        );

        templates.insert(
            "networkmanager".to_string(),
            PluginTemplate {
                name_pattern: "networkmanager".to_string(),
                dbus_service: Some("org.freedesktop.NetworkManager".to_string()),
                capabilities: PluginCapabilities {
                    can_read: true,
                    can_write: true,
                    requires_root: true,
                    ..Default::default()
                },
            },
        );

        templates.insert(
            "packagekit".to_string(),
            PluginTemplate {
                name_pattern: "packagekit".to_string(),
                dbus_service: Some("org.freedesktop.PackageKit".to_string()),
                capabilities: PluginCapabilities {
                    can_read: true,
                    can_write: true,
                    requires_root: true,
                    ..Default::default()
                },
            },
        );

        Self {
            templates: Arc::new(RwLock::new(templates)),
        }
    }

    /// Register a custom template
    pub async fn register_template(&self, name: &str, template: PluginTemplate) {
        let mut templates = self.templates.write().await;
        templates.insert(name.to_string(), template);
    }

    /// Create a plugin by name
    pub async fn create_plugin(&self, name: &str) -> Result<BoxedPlugin> {
        let templates = self.templates.read().await;

        // Check if we have a template
        if let Some(template) = templates.get(name) {
            info!("Creating plugin '{}' from template", name);
            return Ok(Box::new(AutoGeneratedPlugin::from_template(
                name,
                template.clone(),
            )));
        }

        // Try to create a generic plugin
        info!("Creating generic plugin '{}'", name);
        Ok(Box::new(AutoGeneratedPlugin::new(name)))
    }

    /// Check if a plugin can be auto-created
    pub async fn can_create(&self, name: &str) -> bool {
        let templates = self.templates.read().await;
        templates.contains_key(name) || true // Can always create generic
    }
}

impl Default for AutoPluginFactory {
    fn default() -> Self {
        Self::new()
    }
}

/// Auto-generated plugin implementation
pub struct AutoGeneratedPlugin {
    name: String,
    description: String,
    version: String,
    dbus_service: Option<String>,
    capabilities: PluginCapabilities,
    current_state: Arc<RwLock<Value>>,
    desired_state: Arc<RwLock<DesiredState>>,
    storage_path: Arc<RwLock<Option<std::path::PathBuf>>>,
}

impl AutoGeneratedPlugin {
    pub fn new(name: &str) -> Self {
        Self {
            name: name.to_string(),
            description: format!("Auto-generated plugin for {}", name),
            version: "0.1.0-auto".to_string(),
            dbus_service: None,
            capabilities: PluginCapabilities::default(),
            current_state: Arc::new(RwLock::new(json!({}))),
            desired_state: Arc::new(RwLock::new(DesiredState::default())),
            storage_path: Arc::new(RwLock::new(None)),
        }
    }

    pub fn from_template(name: &str, template: PluginTemplate) -> Self {
        Self {
            name: name.to_string(),
            description: format!("Auto-generated plugin for {} (from template)", name),
            version: "0.1.0-auto".to_string(),
            dbus_service: template.dbus_service,
            capabilities: template.capabilities,
            current_state: Arc::new(RwLock::new(json!({}))),
            desired_state: Arc::new(RwLock::new(DesiredState::default())),
            storage_path: Arc::new(RwLock::new(None)),
        }
    }

    /// Load state from storage
    async fn load_state(&self) -> Result<()> {
        let path = self.storage_path.read().await;
        if let Some(ref p) = *path {
            let state_file = p.join("state.json");
            if state_file.exists() {
                let content = tokio::fs::read_to_string(&state_file).await?;
                let state: Value = serde_json::from_str(&content)?;
                *self.current_state.write().await = state;
            }

            let desired_file = p.join("desired.json");
            if desired_file.exists() {
                let content = tokio::fs::read_to_string(&desired_file).await?;
                let desired: DesiredState = serde_json::from_str(&content)?;
                *self.desired_state.write().await = desired;
            }
        }
        Ok(())
    }

    /// Save state to storage
    async fn save_state(&self) -> Result<()> {
        let path = self.storage_path.read().await;
        if let Some(ref p) = *path {
            let state = self.current_state.read().await;
            let state_file = p.join("state.json");
            tokio::fs::write(&state_file, serde_json::to_string_pretty(&*state)?).await?;

            let desired = self.desired_state.read().await;
            let desired_file = p.join("desired.json");
            tokio::fs::write(&desired_file, serde_json::to_string_pretty(&*desired)?).await?;
        }
        Ok(())
    }
}

#[async_trait]
impl Plugin for AutoGeneratedPlugin {
    fn name(&self) -> &str {
        &self.name
    }

    fn description(&self) -> &str {
        &self.description
    }

    fn version(&self) -> &str {
        &self.version
    }

    async fn get_state(&self) -> Result<Value> {
        Ok(self.current_state.read().await.clone())
    }

    async fn get_desired_state(&self) -> Result<DesiredState> {
        Ok(self.desired_state.read().await.clone())
    }

    async fn set_desired_state(&self, desired: DesiredState) -> Result<()> {
        *self.desired_state.write().await = desired;
        self.save_state().await?;
        Ok(())
    }

    async fn apply_state(&self) -> Result<Vec<StateChange>> {
        let changes = self.diff().await?;

        // Apply changes
        let desired = self.desired_state.read().await;
        *self.current_state.write().await = desired.state.clone();

        self.save_state().await?;

        Ok(changes)
    }

    async fn diff(&self) -> Result<Vec<StateChange>> {
        let current = self.current_state.read().await;
        let desired = self.desired_state.read().await;

        let mut changes = Vec::new();

        // Simple diff - compare JSON values
        if *current != desired.state {
            changes.push(StateChange::update(
                "/",
                current.clone(),
                desired.state.clone(),
                "State changed",
            ));
        }

        Ok(changes)
    }

    async fn validate(&self, config: &Value) -> Result<ValidationResult> {
        // Basic validation
        if config.is_object() {
            Ok(ValidationResult::success())
        } else {
            Ok(ValidationResult::failure("Configuration must be an object"))
        }
    }

    fn capabilities(&self) -> PluginCapabilities {
        self.capabilities.clone()
    }

    fn metadata(&self) -> PluginMetadata {
        PluginMetadata {
            name: self.name.clone(),
            version: self.version.clone(),
            description: self.description.clone(),
            dbus_services: self.dbus_service.clone().into_iter().collect(),
            ..Default::default()
        }
    }

    async fn initialize(&mut self, context: PluginContext) -> Result<()> {
        *self.storage_path.write().await = Some(context.storage_path);
        self.load_state().await.ok(); // Ignore errors on load
        debug!("Initialized auto-generated plugin: {}", self.name);
        Ok(())
    }

    async fn cleanup(&mut self) -> Result<()> {
        self.save_state().await?;
        Ok(())
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}
